
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coprime Lattice & Riemann Hypothesis Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #4fc3f7;
            font-size: 28px;
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 20px;
            color: #90caf9;
            font-size: 14px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .controls-panel {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            height: fit-content;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #b0b0b0;
        }
        
        input[type="number"], input[type="range"], select {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        input[type="number"] {
            margin-bottom: 5px;
        }
        
        input[type="range"] {
            padding: 0;
        }
        
        .range-value {
            text-align: right;
            color: #4fc3f7;
            font-size: 11px;
            margin-top: -8px;
            margin-bottom: 10px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: #2196f3;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: background 0.3s;
            margin-bottom: 8px;
        }
        
        button:hover {
            background: #1976d2;
        }
        
        button.secondary {
            background: #455a64;
        }
        
        button.secondary:hover {
            background: #37474f;
        }
        
        .canvas-container {
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            border: 1px solid #444;
            border-radius: 4px;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .stat-card h3 {
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .export-icon {
            cursor: pointer;
            font-size: 16px;
            padding: 4px 8px;
            border-radius: 4px;
            background: #2a2a2a;
            border: 1px solid #444;
            transition: all 0.3s;
        }
        
        .export-icon:hover {
            background: #3a3a3a;
            border-color: #4fc3f7;
        }
        
        .point-inspector {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border: 2px solid #4fc3f7;
            margin-bottom: 15px;
        }
        
        .point-inspector.empty {
            border-color: #444;
            opacity: 0.5;
        }
        
        .point-highlight {
            position: absolute;
            pointer-events: none;
            border: 3px solid #ffff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #2a2a2a;
            font-size: 12px;
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #b0b0b0;
        }
        
        .stat-value {
            color: #4fc3f7;
            font-weight: 600;
        }
        
        .export-section {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }
        
        .checkbox-group label {
            margin-bottom: 0;
        }
        
        .loading {
            text-align: center;
            color: #4fc3f7;
            padding: 20px;
            display: none;
        }
        
        .formula-box {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #4fc3f7;
            margin-bottom: 15px;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .formula-box strong {
            color: #4fc3f7;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #2a2a2a;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
        }
        
        .progress-fill {
            height: 100%;
            background: #4fc3f7;
            width: 0%;
            transition: width 0.3s;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #333;
        }
        
        .tab {
            padding: 12px 24px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            color: #b0b0b0;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .tab:hover {
            background: #2a2a2a;
            color: #4fc3f7;
        }
        
        .tab.active {
            background: #2a2a2a;
            color: #4fc3f7;
            border-bottom: 2px solid #4fc3f7;
            margin-bottom: -2px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .intro-section {
            margin-bottom: 30px;
        }
        
        .intro-section h2 {
            color: #4fc3f7;
            font-size: 20px;
            margin-bottom: 15px;
            border-bottom: 2px solid #333;
            padding-bottom: 8px;
        }
        
        .intro-section h3 {
            color: #90caf9;
            font-size: 16px;
            margin: 20px 0 10px 0;
        }
        
        .intro-section p {
            color: #e0e0e0;
            line-height: 1.8;
            margin-bottom: 12px;
        }
        
        .intro-section ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .intro-section li {
            color: #e0e0e0;
            line-height: 1.8;
            margin-bottom: 8px;
        }
        
        .math-formula {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #4fc3f7;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            color: #90caf9;
            font-size: 14px;
        }
        
        .highlight-box {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #4fc3f7;
            margin: 15px 0;
        }
        
        .highlight-box strong {
            color: #4fc3f7;
        }
        
        .example-box {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            margin: 15px 0;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .feature-card {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #444;
        }
        
        .feature-card h4 {
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .feature-card p {
            font-size: 12px;
            color: #b0b0b0;
            margin: 0;
        }
        
        .keyboard-help {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #1a1a1a;
            border: 2px solid #4fc3f7;
            border-radius: 8px;
            padding: 30px;
            z-index: 10000;
            max-width: 600px;
            box-shadow: 0 0 40px rgba(79, 195, 247, 0.3);
            display: none;
        }
        
        .keyboard-help.show {
            display: block;
        }
        
        .keyboard-help h2 {
            color: #4fc3f7;
            margin-bottom: 20px;
            text-align: center;
        }
        
        .keyboard-help table {
            width: 100%;
            border-collapse: collapse;
        }
        
        .keyboard-help td {
            padding: 8px;
            border-bottom: 1px solid #333;
        }
        
        .keyboard-help .key {
            color: #4fc3f7;
            font-family: monospace;
            font-weight: bold;
            text-align: right;
            padding-right: 20px;
            white-space: nowrap;
        }
        
        .keyboard-help .action {
            color: #e0e0e0;
        }
        
        .keyboard-help button {
            width: 100%;
            margin-top: 20px;
        }
        
        .help-icon {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 50px;
            height: 50px;
            background: #4fc3f7;
            color: #0a0a0a;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(79, 195, 247, 0.4);
            transition: all 0.3s;
            z-index: 9999;
        }
        
        .help-icon:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 16px rgba(79, 195, 247, 0.6);
        }
        
        .status-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: rgba(26, 26, 26, 0.95);
            border-bottom: 1px solid #4fc3f7;
            padding: 8px 20px;
            display: none;
            align-items: center;
            justify-content: space-between;
            z-index: 10000;
            backdrop-filter: blur(10px);
        }
        
        .status-bar.show {
            display: flex;
        }
        
        .status-text {
            color: #4fc3f7;
            font-size: 14px;
            font-weight: 600;
        }
        
        .status-close {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 20px;
            padding: 0;
            width: 24px;
            height: 24px;
        }
        
        .status-close:hover {
            color: #4fc3f7;
        }
        
        .tooltip {
            position: absolute;
            background: #1a1a1a;
            border: 1px solid #4fc3f7;
            border-radius: 4px;
            padding: 8px 12px;
            color: #e0e0e0;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            display: none;
            max-width: 300px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }
        
        .canvas-container {
            position: relative;
        }
        
        canvas {
            cursor: grab;
        }
        
        canvas:active {
            cursor: grabbing;
        }
        
        kbd {
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 3px;
            padding: 2px 6px;
            font-family: monospace;
            font-size: 11px;
            color: #4fc3f7;
        }
        
        .stat-card:hover {
            border-color: #4fc3f7;
            transition: border-color 0.3s;
        }
        
        @media (max-width: 1400px) {
            .main-grid {
                grid-template-columns: 1fr;
            }
            .controls-panel {
                max-width: 100%;
            }
        }
        
        @media print {
            .controls-panel, .help-icon, .tabs {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Coprime Lattice & Riemann Hypothesis Explorer</h1>
        <div class="subtitle">Interactive visualization of primitive lattice vectors, gcd(a,b)=1 patterns, and their deep connection to Œ∂(s) zeros</div>
        
        <div class="tabs">
            <div class="tab" data-tab="intro">Introduction</div>
            <div class="tab active" data-tab="explorer">Explorer</div>
        </div>
        
        <div id="introTab" class="tab-content">
            <div class="intro-section">
                <h2>Welcome to the Coprime Lattice Explorer</h2>
                <p>
                    This tool provides an interactive visualization of one of the most beautiful connections in mathematics: 
                    the relationship between <strong>coprime integer pairs</strong> (primitive lattice vectors) and the 
                    <strong>Riemann Hypothesis</strong>, one of the most important unsolved problems in mathematics.
                </p>
                
                <div class="highlight-box">
                    <strong>Main Theorem:</strong> The probability that two random integers are coprime converges to 
                    <strong>6/œÄ¬≤ ‚âà 0.6079</strong>, which equals <strong>1/Œ∂(2)</strong>.
                </div>
                
                <p>
                    This explorer focuses on <strong>primitive lattice vectors</strong> - points (a,b) where gcd(a,b) = 1, 
                    also known as "visible points" from the origin. These points form the building blocks of the integer 
                    lattice and have profound connections to Gaussian integers, Fermat's Two-Square Theorem, and the 
                    distribution of prime numbers.
                </p>
            </div>
            
            <div class="intro-section">
                <h2>What Are Coprime Numbers?</h2>
                <p>
                    Two integers <em>a</em> and <em>b</em> are <strong>coprime</strong> (or relatively prime) if their 
                    greatest common divisor (GCD) is 1. In other words, they share no common factors except 1. These 
                    pairs form <strong>primitive lattice vectors</strong> that are "visible" from the origin when you 
                    imagine standing at (0,0) and looking through the lattice.
                </p>
                
                <div class="example-box">
                    <strong>Examples:</strong>
                    <ul>
                        <li>gcd(8, 15) = 1 ‚Üí Coprime ‚úì (Primitive vector)</li>
                        <li>gcd(12, 18) = 6 ‚Üí Not coprime ‚úó (Blocked by (2,3))</li>
                        <li>gcd(7, 11) = 1 ‚Üí Coprime ‚úì (Primitive vector)</li>
                    </ul>
                </div>
                
                <h3>Gaussian Integers & Norm</h3>
                <p>
                    Each lattice point (a,b) corresponds to a <strong>Gaussian integer</strong> z = a + bi. 
                    The norm is N(z) = a¬≤ + b¬≤, which measures the squared distance from the origin. 
                    <strong>Fermat's Two-Square Theorem</strong> states that a prime p can be written as a sum of 
                    two squares (p = a¬≤ + b¬≤) if and only if p ‚â° 1 (mod 4) or p = 2.
                </p>
                
                <p>
                    A fundamental result in number theory states that the probability that two randomly chosen integers 
                    are coprime is <strong>6/œÄ¬≤</strong> ‚âà 0.607927. This remarkable constant connects the geometry of 
                    circles (œÄ) with the distribution of prime numbers!
                </p>
                
                <div class="math-formula">
                    P(gcd(a,b) = 1) = 6/œÄ¬≤ = 1/Œ∂(2) = Œ£ 1/n¬≤ = 1 - 1/4 - 1/9 - 1/25 + ...
                </div>
            </div>
            
            <div class="intro-section">
                <h2>The Riemann Zeta Function</h2>
                <p>
                    The <strong>Riemann zeta function</strong> Œ∂(s) is defined for complex numbers s with Re(s) > 1 as:
                </p>
                
                <div class="math-formula">
                    Œ∂(s) = Œ£(n=1 to ‚àû) 1/n^s = 1/1^s + 1/2^s + 1/3^s + 1/4^s + ...
                </div>
                
                <p>
                    This function has a deep connection to prime numbers through the Euler product formula:
                </p>
                
                <div class="math-formula">
                    Œ∂(s) = ‚àè(p prime) 1/(1 - p^(-s))
                </div>
                
                <p>
                    The reciprocal of Œ∂(s) can be expressed using the <strong>M√∂bius function</strong> Œº(n):
                </p>
                
                <div class="math-formula">
                    1/Œ∂(s) = Œ£(n=1 to ‚àû) Œº(n)/n^s
                </div>
                
                <p>
                    where Œº(n) = 1 if n is a product of an even number of distinct primes, 
                    -1 if n is a product of an odd number of distinct primes, and 0 if n has a squared prime factor.
                </p>
            </div>
            
            <div class="intro-section">
                <h2>The Riemann Hypothesis</h2>
                <p>
                    The <strong>Riemann Hypothesis</strong> (RH) is one of the seven Millennium Prize Problems, 
                    with a $1 million prize for its proof. It states:
                </p>
                
                <div class="highlight-box">
                    <strong>Riemann Hypothesis:</strong> All non-trivial zeros of the Riemann zeta function Œ∂(s) 
                    lie on the critical line Re(s) = 1/2 in the complex plane.
                </div>
                
                <p>
                    In other words, if Œ∂(s) = 0 and s is not a negative even integer, then s = 1/2 + it for some real number t.
                </p>
            </div>
            
            <div class="intro-section">
                <h2>Connection to Coprime Lattice Points</h2>
                <p>
                    Let <strong>V(R)</strong> be the number of coprime lattice points (a, b) inside a disc of radius R 
                    centered at the origin. The Gauss Circle Problem and related theory tell us:
                </p>
                
                <div class="math-formula">
                    V(R) = (6/œÄ¬≤) ¬∑ œÄR¬≤ + E(R)
                </div>
                
                <p>
                    where E(R) is the error term. The <strong>exponent in the error bound</strong> is directly related 
                    to the zeros of Œ∂(s):
                </p>
                
                <div class="highlight-box">
                    <strong>Key Connection:</strong> The Riemann Hypothesis is equivalent to the statement that 
                    <strong>|E(R)| = O(R^(1/2 + Œµ))</strong> for any Œµ > 0.
                    <br><br>
                    The exponent <strong>1/2</strong> here is exactly <strong>Re(s) = 1/2</strong> from the critical line!
                </div>
                
                <p>
                    This means that how coprime lattice points distribute in a circular region is fundamentally 
                    connected to where the zeros of Œ∂(s) lie in the complex plane.
                </p>
            </div>
            
            <div class="intro-section">
                <h2>Tool Features</h2>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>Grid Parameters</h4>
                        <p>Generate lattice grids from 1√ó1 up to 10,000√ó10,000 points with customizable resolution and point size.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Color Schemes</h4>
                        <p>Multiple visualization modes including classic, heatmap, rainbow by GCD, and more to highlight different patterns.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Disc Analysis</h4>
                        <p>Compute V(R), the error term E(R), and verify the relationship to RH by analyzing circular regions.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>M√∂bius Statistics</h4>
                        <p>Calculate M√∂bius function sums and verify convergence to 1/Œ∂(2) = 6/œÄ¬≤.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Zoom & Pan</h4>
                        <p>Zoom up to 20x and pan around to explore specific regions in detail.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Point Labels</h4>
                        <p>Label points by GCD, fraction, coordinates, or reduced fraction with customizable appearance.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Point Inspector</h4>
                        <p>Click any point to see its properties: GCD, polar coordinates, modular properties, and more.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Export Options</h4>
                        <p>Export visualizations as PNG (with statistics), SVG, CSV (23 properties per point), or JSON statistics. Comprehensive data includes polar coordinates, Gaussian integer properties, Farey fractions, and modular residues.</p>
                    </div>
                </div>
            </div>
            
            <div class="intro-section">
                <h2>How to Use This Tool</h2>
                
                <h3>1. Basic Exploration</h3>
                <ul>
                    <li>Click the "Explorer" tab above to access the interactive tool</li>
                    <li>Start with a moderate grid size (500√ó500) and click "Generate Visualization"</li>
                    <li>Green/white points are coprime pairs; other colors indicate non-coprime pairs</li>
                    <li>Observe the density and distribution patterns</li>
                </ul>
                
                <h3>2. Analyzing the Riemann Hypothesis Connection</h3>
                <ul>
                    <li>Enable "Show Radius Circle" in the Visualization section</li>
                    <li>Adjust the circle radius R to different values</li>
                    <li>Check the "Disc Analysis" statistics to see V(R), E(R), and |E(R)|/R^(1/2)</li>
                    <li>The ratio |E(R)|/R^(1/2) should remain bounded if RH is true</li>
                </ul>
                
                <h3>3. Detailed Point Inspection</h3>
                <ul>
                    <li>Click on any point in the visualization</li>
                    <li>The "Point Inspector" panel shows: coordinates, GCD, polar form, modular properties</li>
                    <li>Compare coprime vs non-coprime points to understand the patterns</li>
                </ul>
                
                <h3>4. Zooming and Labeling</h3>
                <ul>
                    <li>Use the Zoom slider to magnify regions (up to 20x)</li>
                    <li>Pan using the X and Y offset sliders</li>
                    <li>Enable "Show Point Labels" and choose a label type</li>
                    <li>Adjust font size and threshold for optimal visibility</li>
                </ul>
                
                <h3>5. Statistical Analysis</h3>
                <ul>
                    <li>Check "Global Statistics" for overall coprime density (should approach 6/œÄ¬≤ ‚âà 0.6079)</li>
                    <li>Review "M√∂bius Function Analysis" to see Œ£Œº(n)/n¬≤ converging to 6/œÄ¬≤</li>
                    <li>Export statistics as JSON for further analysis</li>
                    <li><strong>Comprehensive exports:</strong> CSV includes 23 properties per point (polar, Gaussian, Farey, modular)</li>
                </ul>
            </div>
            
            <div class="intro-section">
                <h2>Mathematical Background</h2>
                
                <h3>Why 6/œÄ¬≤?</h3>
                <p>
                    The probability that gcd(a,b) = 1 equals 6/œÄ¬≤ because:
                </p>
                <div class="math-formula">
                    P(gcd(a,b) = 1) = ‚àè(p prime) P(p does not divide both a and b)
                    = ‚àè(p prime) (1 - 1/p¬≤)
                    = 1/Œ∂(2) = 1/(œÄ¬≤/6) = 6/œÄ¬≤
                </div>
                
                <h3>Key Mathematical Results</h3>
                <div class="example-box">
                    <strong>Coprime Density:</strong> lim P(gcd(a,b)=1) = 6/œÄ¬≤ = 1/Œ∂(2)<br>
                    <strong>Average Totient:</strong> lim (1/N)Œ£œÜ(m)/m = 6/œÄ¬≤<br>
                    <strong>Farey Growth:</strong> |F_n| ~ (3/œÄ¬≤)n¬≤<br>
                    <strong>Primitive Vectors:</strong> Count in disc of radius R ~ (6/œÄ)R¬≤<br>
                    <strong>Euler Product:</strong> Œ∂(s) = ‚àè(1 - p^(-s))^(-1) over all primes p<br>
                    <strong>M√∂bius Function:</strong> ùüô_gcd=1 = Œ£ Œº(d) over divisors d<br>
                    <strong>RH Connection:</strong> Error term E(R) = O(R^(1/2+Œµ)) ‚ü∫ Riemann Hypothesis
                </div>
                
                <h3>The Error Term and RH</h3>
                <p>
                    If we count coprime points in a disc, the main term is (6/œÄ¬≤)œÄR¬≤ = 6R¬≤/œÄ. 
                    The error E(R) measures the deviation from this expectation. 
                    Better bounds on E(R) are equivalent to information about Œ∂(s) zeros:
                </p>
                <ul>
                    <li><strong>E(R) = O(R)</strong> is easy to prove (trivial bound)</li>
                    <li><strong>E(R) = O(R^(2/3))</strong> can be proven unconditionally</li>
                    <li><strong>E(R) = O(R^(1/2 + Œµ))</strong> is equivalent to RH</li>
                    <li><strong>E(R) = O(R^(1/2))</strong> would be the best possible bound</li>
                </ul>
                
                <h3>M√∂bius Function and Prime Numbers</h3>
                <p>
                    The M√∂bius function Œº(n) encodes information about the prime factorization of n:
                </p>
                <ul>
                    <li>Œº(n) = 1 if n is a product of an <strong>even</strong> number of distinct primes</li>
                    <li>Œº(n) = -1 if n is a product of an <strong>odd</strong> number of distinct primes</li>
                    <li>Œº(n) = 0 if n has a squared prime factor</li>
                </ul>
                <p>
                    Its summatory properties are intimately connected to the distribution of primes and 
                    the zeros of Œ∂(s). The sum M(N) = Œ£Œº(n) oscillates around zero, and RH implies 
                    |M(N)| = O(N^(1/2 + Œµ)).
                </p>
                
                <h3>Euler's Totient Function œÜ(m)</h3>
                <p>
                    The <strong>totient function</strong> œÜ(m) counts how many integers from 1 to m are coprime to m. 
                    The ratio œÜ(m)/m represents the "coprime density" for a specific modulus m. Averaging these ratios 
                    over all moduli converges to 6/œÄ¬≤.
                </p>
                <div class="math-formula">
                    lim (n‚Üí‚àû) (1/n) Œ£(m=1 to n) œÜ(m)/m = 6/œÄ¬≤
                </div>
                <p>
                    Note: While primes have œÜ(p)/p = (p-1)/p ‚Üí 1, which is higher than 6/œÄ¬≤ ‚âà 0.608, primes become 
                    increasingly sparse, so composite numbers with lower ratios dominate the average.
                </p>
            </div>
            
            <div class="intro-section">
                <h2>Ready to Explore?</h2>
                <p>
                    Click the <strong>"Explorer"</strong> tab above to begin your journey into the beautiful 
                    world of coprime lattice points and their connection to one of mathematics' deepest mysteries!
                </p>
                
                <div class="highlight-box">
                    <strong>Technical Features:</strong>
                    <ul style="margin: 10px 0 0 0;">
                        <li>Grid sizes from 1√ó1 to 10,000√ó10,000</li>
                        <li>High-resolution canvas rendering (2K/4K/8K export)</li>
                        <li>Real-time statistics with disc analysis</li>
                        <li>Zoom up to 20x with pan controls</li>
                        <li>Point inspector with polar/modular properties</li>
                        <li>Multiple color schemes and labeling options</li>
                        <li>Export to PNG (with legend), SVG, CSV, and JSON</li>
                        <li>Professional academic styling</li>
                        <li>Mobile-compatible interface</li>
                    </ul>
                </div>
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #333; text-align: center; color: #888; font-size: 12px;">
                    <p><strong>Author:</strong> Wessen Getachew (<a href="https://twitter.com/7dview" style="color: #4fc3f7;">@7dview</a>)</p>
                    <p><strong>Theme:</strong> Classical analytic number theory with modern interactive visualization</p>
                    <p style="margin-top: 10px;">Built with HTML5 Canvas ‚Ä¢ Pure JavaScript ‚Ä¢ No external dependencies</p>
                </div>
            </div>
        </div>
        
        <div id="explorerTab" class="tab-content active">
        <div class="main-grid">
            <div class="controls-panel">
                <div class="control-group">
                    <h3>Point Inspector</h3>
                    <div id="pointInspector" class="point-inspector empty">
                        <div style="text-align: center; color: #888; font-size: 12px;">
                            Click on a point to inspect its properties
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Grid Parameters</h3>
                    <label title="Size of the lattice grid (N √ó N points)">Grid Size (N √ó N)</label>
                    <input type="number" id="gridSizeInput" min="1" max="10000" value="500" step="1">
                    <input type="range" id="gridSize" min="1" max="10000" value="500" step="1">
                    <div class="range-value" id="gridSizeValue">500</div>
                    
                    <label title="Output resolution for rendering and export">Canvas Resolution</label>
                    <select id="resolution">
                        <option value="2048">2K (2048px)</option>
                        <option value="3840" selected>4K (3840px)</option>
                        <option value="7680">8K (7680px)</option>
                    </select>
                    
                    <label title="Size of each point in pixels">Point Size (pixels)</label>
                    <input type="range" id="pointSize" min="1" max="10" value="3" step="1">
                    <div class="range-value" id="pointSizeValue">3</div>
                </div>
                
                <div class="control-group">
                    <h3>Visualization</h3>
                    <label>Color Scheme</label>
                    <select id="colorScheme">
                        <option value="classic">Classic (Green/Blue)</option>
                        <option value="heatmap">Heatmap</option>
                        <option value="monochrome">Monochrome</option>
                        <option value="rainbow">Rainbow by GCD</option>
                        <option value="neon">Neon</option>
                        <option value="colorblind">Colorblind Safe (Orange/Blue)</option>
                        <option value="highcontrast">High Contrast (Yellow/Black)</option>
                    </select>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showCircle">
                        <label title="Show circular region for disc analysis">Show Radius Circle</label>
                    </div>
                    
                    <label title="Radius as percentage of grid size">Circle Radius (R)</label>
                    <input type="range" id="circleRadius" min="10" max="100" value="40" step="5" disabled>
                    <div class="range-value" id="circleRadiusValue">40%</div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showAxes" checked>
                        <label>Show Axes</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGrid">
                        <label>Show Grid Lines</label>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Mathematical Overlays</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showDiagonals">
                        <label>Show Diagonals (y=x, y=-x)</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showCustomLine">
                        <label>Show Custom Line y=mx</label>
                    </div>
                    
                    <label>Slope m</label>
                    <input type="number" id="customSlope" value="2" step="0.1" disabled>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showHyperbola">
                        <label>Show Hyperbola xy=k</label>
                    </div>
                    
                    <label>Constant k</label>
                    <input type="number" id="hyperbolaK" value="100" step="10" disabled>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="highlightModular">
                        <label>Highlight Modular Classes</label>
                    </div>
                    
                    <label>Modulus</label>
                    <select id="modulus" disabled>
                        <option value="2">mod 2</option>
                        <option value="3">mod 3</option>
                        <option value="4">mod 4</option>
                        <option value="5">mod 5</option>
                        <option value="6">mod 6</option>
                    </select>
                    
                    <label>Residue Class (a mod m)</label>
                    <input type="number" id="residueA" value="0" min="0" disabled>
                    
                    <label>Residue Class (b mod m)</label>
                    <input type="number" id="residueB" value="0" min="0" disabled>
                </div>
                
                <div class="control-group">
                    <h3>Advanced Analysis</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showFarey">
                        <label>Show Farey Sequence F_n</label>
                    </div>
                    
                    <label>Farey Order n</label>
                    <input type="number" id="fareyOrder" value="5" min="1" max="50" step="1" disabled>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="primeFilter">
                        <label title="Show only points where a or b is prime">Prime Filter (a or b prime)</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showRadialDensity">
                        <label title="Plot coprime density vs. radius">Show Radial Density Plot</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showAngularDist">
                        <label title="Show distribution by angular sectors">Show Angular Distribution</label>
                    </div>
                    
                    <label>Angular Sectors</label>
                    <input type="number" id="angularSectors" value="12" min="4" max="36" step="4" disabled>
                </div>
                
                <div class="control-group">
                    <h3>Labels</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showLabels">
                        <label>Show Point Labels</label>
                    </div>
                    
                    <label>Label Type</label>
                    <select id="labelType" disabled>
                        <option value="gcd">GCD Value</option>
                        <option value="fraction">a/b Fraction</option>
                        <option value="coordinates">Coordinates (a,b)</option>
                        <option value="reduced">Reduced Fraction</option>
                    </select>
                    
                    <label>Label Threshold (max points to label)</label>
                    <input type="range" id="labelThreshold" min="10" max="500" value="100" step="10" disabled>
                    <div class="range-value" id="labelThresholdValue">100</div>
                    
                    <label>Font Size</label>
                    <input type="range" id="labelFontSize" min="8" max="24" value="12" step="1" disabled>
                    <div class="range-value" id="labelFontSizeValue">12px</div>
                </div>
                
                <div class="control-group">
                    <h3>Zoom & Pan</h3>
                    <label>Zoom Level</label>
                    <input type="range" id="zoomLevel" min="1" max="20" value="1" step="0.5">
                    <div class="range-value" id="zoomLevelValue">1.0x</div>
                    
                    <label>Center X (offset)</label>
                    <input type="text" id="panXInput" value="0" placeholder="0 or fraction like 1/2">
                    <input type="range" id="panX" min="-100" max="100" value="0" step="1">
                    <div class="range-value" id="panXValue">0%</div>
                    
                    <label>Center Y (offset)</label>
                    <input type="text" id="panYInput" value="0" placeholder="0 or fraction like -1/3">
                    <input type="range" id="panY" min="-100" max="100" value="0" step="1">
                    <div class="range-value" id="panYValue">0%</div>
                    
                    <button class="secondary" id="resetZoom">Reset Zoom & Pan</button>
                </div>
                
                <div class="control-group">
                    <h3>Analysis</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="analyzeDisc" checked>
                        <label>Analyze Disc Region</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showDensity" checked>
                        <label>Calculate Density Statistics</label>
                    </div>
                </div>
                
                <button id="generateBtn" title="Generate new visualization (Spacebar)">Generate Visualization</button>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="loading" id="loading">Computing...</div>
                
                <div class="control-group">
                    <h3>Export</h3>
                    <div class="export-section">
                        <button class="secondary" id="exportPNG" title="Export full grid view (ignores pan/zoom)">PNG</button>
                        <button class="secondary" id="exportSVG" title="Vector graphics with full grid">SVG</button>
                        <button class="secondary" id="exportCSV" title="Comprehensive data with 23 properties per point">CSV</button>
                    </div>
                    <button class="secondary" id="exportStats" title="JSON with full mathematical properties">Export Statistics (JSON)</button>
                    <button class="secondary" id="exportHTML">Export Interactive HTML</button>
                    <button class="secondary" id="copyStats">Copy Stats to Clipboard</button>
                    
                    <div style="margin-top: 10px; padding: 10px; background: #2a2a2a; border-radius: 4px; border: 1px solid #444;">
                        <div style="font-size: 11px; color: #90caf9; margin-bottom: 5px;">üìä Comprehensive Exports:</div>
                        <div style="font-size: 10px; color: #b0b0b0; line-height: 1.5;">
                            ‚Ä¢ PNG: Full grid view (resets zoom/pan)<br>
                            ‚Ä¢ CSV: 23 properties per point including polar, Gaussian integer, Farey fractions, modular properties<br>
                            ‚Ä¢ JSON: Nested structure with all mathematical data
                        </div>
                    </div>
                    
                    <div style="margin-top: 15px; padding-top: 15px; border-top: 1px solid #333;">
                        <label>Batch Export (Multiple Radii)</label>
                        <input type="text" id="batchRadii" placeholder="20,40,60,80" style="margin-bottom: 8px;">
                        <button class="secondary" id="batchExport">Batch Export PNGs</button>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Presets</h3>
                    <select id="presetSelect" style="margin-bottom: 8px;">
                        <option value="">-- Select Preset --</option>
                        <option value="prime-focus">Prime Focus (Filter + Diagonals)</option>
                        <option value="rh-analysis">RH Analysis (Circle + Plots)</option>
                        <option value="farey-explorer">Farey Explorer (F_10 + Lines)</option>
                        <option value="modular-patterns">Modular Patterns (mod 3)</option>
                        <option value="high-res">High Resolution (1000√ó1000, 8K)</option>
                        <option value="minimal">Minimal (Clean, No Overlays)</option>
                    </select>
                    <button class="secondary" id="applyPreset">Apply Preset</button>
                    <button class="secondary" id="savePreset">Save Current as Preset</button>
                </div>
                
                <div class="formula-box">
                    <strong>Riemann Hypothesis Connection:</strong><br>
                    V(R) = (6/œÄ¬≤)œÄR¬≤ + O(R^(1/2+Œµ))<br><br>
                    The exponent <strong>1/2</strong> in the error term is exactly <strong>Re(s) = 1/2</strong> on the critical line.
                </div>
            </div>
            
            <div class="canvas-container">
                <div style="position: relative; display: inline-block;">
                    <canvas id="canvas" role="img" aria-label="Coprime lattice visualization showing primitive vectors where gcd(a,b)=1"></canvas>
                    <div id="pointHighlight" class="point-highlight"></div>
                    <div id="tooltip" class="tooltip"></div>
                </div>
                <div id="ariaLive" aria-live="polite" aria-atomic="true" style="position: absolute; left: -10000px; width: 1px; height: 1px; overflow: hidden;"></div>
            </div>
        </div>
        
        <div class="help-icon" id="helpIcon" title="Keyboard Shortcuts (Press ?)">?</div>
        
        <div class="keyboard-help" id="keyboardHelp">
            <h2>‚å®Ô∏è Keyboard Shortcuts</h2>
            <table>
                <tr><td class="key">?</td><td class="action">Toggle this help</td></tr>
                <tr><td class="key">Space</td><td class="action">Regenerate visualization</td></tr>
                <tr><td class="key">G</td><td class="action">Toggle grid lines</td></tr>
                <tr><td class="key">A</td><td class="action">Toggle axes</td></tr>
                <tr><td class="key">C</td><td class="action">Toggle radius circle</td></tr>
                <tr><td class="key">D</td><td class="action">Toggle diagonals</td></tr>
                <tr><td class="key">F</td><td class="action">Toggle Farey sequence</td></tr>
                <tr><td class="key">P</td><td class="action">Toggle prime filter</td></tr>
                <tr><td class="key">R</td><td class="action">Toggle radial density plot</td></tr>
                <tr><td class="key">L</td><td class="action">Toggle point labels</td></tr>
                <tr><td class="key">‚Üë ‚Üì ‚Üê ‚Üí</td><td class="action">Pan view (5% increments)</td></tr>
                <tr><td class="key">Shift + ‚Üë‚Üì‚Üê‚Üí</td><td class="action">Pan view (1% increments)</td></tr>
                <tr><td class="key">+ / =</td><td class="action">Zoom in</td></tr>
                <tr><td class="key">- / _</td><td class="action">Zoom out</td></tr>
                <tr><td class="key">0</td><td class="action">Reset zoom and pan</td></tr>
                <tr><td class="key">1-6</td><td class="action">Apply preset 1-6</td></tr>
                <tr><td class="key">E</td><td class="action">Export PNG</td></tr>
                <tr><td class="key">S</td><td class="action">Export SVG</td></tr>
                <tr><td class="key">J</td><td class="action">Export JSON statistics</td></tr>
                <tr><td class="key">Ctrl/Cmd + C</td><td class="action">Copy statistics to clipboard</td></tr>
            </table>
            <button onclick="document.getElementById('keyboardHelp').classList.remove('show')">Close (Esc)</button>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card" id="radialDensityCard" style="display: none;">
                <h3>
                    Radial Density Plot
                    <span class="export-icon" onclick="exportChart('radialCanvas', 'radial_density')" title="Export Chart">üíæ</span>
                </h3>
                <canvas id="radialCanvas" width="600" height="300" style="width: 100%; height: auto; border: 1px solid #444; border-radius: 4px;"></canvas>
            </div>
            
            <div class="stat-card" id="angularDistCard" style="display: none;">
                <h3>
                    Angular Distribution
                    <span class="export-icon" onclick="exportChart('angularCanvas', 'angular_distribution')" title="Export Chart">üíæ</span>
                </h3>
                <canvas id="angularCanvas" width="600" height="300" style="width: 100%; height: auto; border: 1px solid #444; border-radius: 4px;"></canvas>
            </div>
            
            <div class="stat-card">
                <h3>Global Statistics</h3>
                <div id="globalStats">
                    <div class="stat-row">
                        <span class="stat-label">Total Points:</span>
                        <span class="stat-value" id="totalPoints">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Coprime Points:</span>
                        <span class="stat-value" id="coprimePoints">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Non-Coprime Points:</span>
                        <span class="stat-value" id="nonCoprimePoints">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Coprime Density:</span>
                        <span class="stat-value" id="coprimeDensity">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Theoretical (6/œÄ¬≤):</span>
                        <span class="stat-value">0.607927</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Relative Error:</span>
                        <span class="stat-value" id="relativeError">-</span>
                    </div>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>Disc Analysis (Radius R)</h3>
                <div id="discStats">
                    <div class="stat-row">
                        <span class="stat-label">Radius R:</span>
                        <span class="stat-value" id="discRadius">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Points in Disc:</span>
                        <span class="stat-value" id="discTotal">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Coprime in Disc V(R):</span>
                        <span class="stat-value" id="discCoprime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Expected (6/œÄ¬≤)œÄR¬≤:</span>
                        <span class="stat-value" id="discExpected">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Error E(R):</span>
                        <span class="stat-value" id="discError">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">|E(R)|/R^(1/2):</span>
                        <span class="stat-value" id="errorRatio">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">log‚ÇÅ‚ÇÄ|E(R)|:</span>
                        <span class="stat-value" id="errorLog">-</span>
                    </div>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>M√∂bius Function Analysis</h3>
                <div id="mobiusStats">
                    <div class="stat-row">
                        <span class="stat-label">M(N) = Œ£Œº(n):</span>
                        <span class="stat-value" id="mobiusSum">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">|M(N)|/N^(1/2):</span>
                        <span class="stat-value" id="mobiusRatio">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Œ£Œº(n)/n:</span>
                        <span class="stat-value" id="mobiusNormalized">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Œ£Œº(n)/n¬≤:</span>
                        <span class="stat-value" id="mobiusSquared">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Expected (1/Œ∂(2)):</span>
                        <span class="stat-value">0.607927</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">GCD Values Found:</span>
                        <span class="stat-value" id="gcdCount">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Œº-Function Range:</span>
                        <span class="stat-value" id="mobiusRange">-1 to +1</span>
                    </div>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>Computational Details</h3>
                <div id="computeStats">
                    <div class="stat-row">
                        <span class="stat-label">Grid Dimensions:</span>
                        <span class="stat-value" id="dimensions">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Canvas Size:</span>
                        <span class="stat-value" id="canvasSize">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Point Size:</span>
                        <span class="stat-value" id="pointSizeStat">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Pixels:</span>
                        <span class="stat-value" id="totalPixels">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Generation Time:</span>
                        <span class="stat-value" id="genTime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Memory (approx):</span>
                        <span class="stat-value" id="memUsage">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Color Scheme:</span>
                        <span class="stat-value" id="colorSchemeUsed">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Zoom Level:</span>
                        <span class="stat-value" id="zoomStat">1.0x</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Performance:</span>
                        <span class="stat-value" id="perfRating">-</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 30px; padding: 20px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333; text-align: center;">
            <div style="color: #4fc3f7; font-size: 16px; font-weight: bold; margin-bottom: 15px;">üí° Quick Tips</div>
            <div style="color: #b0b0b0; font-size: 12px; line-height: 1.8; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; text-align: left;">
                <div>
                    <strong style="color: #4fc3f7;">üñ±Ô∏è Mouse:</strong> 
                    <ul style="margin: 5px 0 0 20px; padding: 0;">
                        <li>Drag canvas to pan</li>
                        <li>Scroll wheel to zoom</li>
                        <li>Hover for quick info</li>
                        <li>Click for details</li>
                    </ul>
                </div>
                <div>
                    <strong style="color: #4fc3f7;">‚å®Ô∏è Keyboard:</strong>
                    <ul style="margin: 5px 0 0 20px; padding: 0;">
                        <li>Press <kbd>?</kbd> for shortcuts</li>
                        <li><kbd>Space</kbd> to regenerate</li>
                        <li>Arrow keys to pan</li>
                        <li><kbd>+/-</kbd> to zoom</li>
                    </ul>
                </div>
                <div>
                    <strong style="color: #4fc3f7;">üéØ Analysis:</strong>
                    <ul style="margin: 5px 0 0 20px; padding: 0;">
                        <li>Enable circle for RH error</li>
                        <li>Use presets (1-6 keys)</li>
                        <li>Prime filter reveals patterns</li>
                        <li>Plots show convergence</li>
                    </ul>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 30px; padding: 20px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333; text-align: center;">
            <div style="color: #4fc3f7; font-size: 16px; font-weight: bold; margin-bottom: 15px;">About This Tool</div>
            <div style="color: #b0b0b0; font-size: 12px; line-height: 1.8;">
                <p style="margin-bottom: 10px;">
                    <strong style="color: #90caf9;">Coprime Lattice & Riemann Hypothesis Explorer</strong> visualizes primitive lattice vectors 
                    and their deep connections to the Riemann zeta function, Gaussian integers, and the distribution of primes.
                </p>
                <p style="margin-bottom: 10px;">
                    Built using HTML5 Canvas with pure JavaScript. Implements efficient GCD computation via Euclidean algorithm, 
                    M√∂bius function evaluation, and real-time statistical analysis of coprime density convergence to 6/œÄ¬≤ ‚âà 0.607927.
                </p>
                <p style="margin-bottom: 15px;">
                    <strong style="color: #90caf9;">Key Features:</strong> Zoom & pan, point inspection with polar/modular properties, 
                    disc analysis for RH error bounds, multiple export formats (PNG with legend, SVG, CSV, JSON), 
                    customizable labeling and color schemes.
                </p>
                <div style="padding-top: 15px; border-top: 1px solid #333;">
                    <strong style="color: #4fc3f7;">Author:</strong> Wessen Getachew 
                    (<a href="https://twitter.com/7dview" target="_blank" style="color: #4fc3f7; text-decoration: none;">@7dview</a>) | 
                    <strong style="color: #4fc3f7;">Theme:</strong> Classical analytic number theory with modern interactive visualization
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.getAttribute('data-tab');
                
                // Update active tab
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                if (targetTab === 'intro') {
                    document.getElementById('introTab').classList.add('active');
                } else if (targetTab === 'explorer') {
                    document.getElementById('explorerTab').classList.add('active');
                }
            });
        });
        
        // GCD function using Euclidean algorithm
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b !== 0) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }
        
        // Simplify fraction
        function simplifyFraction(a, b) {
            if (b === 0) return {num: a, den: 1};
            const g = gcd(a, b);
            return {num: a / g, den: b / g};
        }
        
        // Calculate angle in degrees
        function angleDegrees(a, b) {
            if (a === 0 && b === 0) return 0;
            const rad = Math.atan2(b, a);
            const deg = rad * (180 / Math.PI);
            return deg < 0 ? deg + 360 : deg;
        }
        
        // Calculate polar radius
        function polarRadius(a, b) {
            return Math.sqrt(a * a + b * b);
        }
        
        // M√∂bius function
        function mobius(n) {
            if (n === 1) return 1;
            
            let factors = [];
            let temp = n;
            
            for (let i = 2; i * i <= temp; i++) {
                if (temp % i === 0) {
                    let count = 0;
                    while (temp % i === 0) {
                        temp /= i;
                        count++;
                    }
                    if (count > 1) return 0; // squared factor
                    factors.push(i);
                }
            }
            
            if (temp > 1) factors.push(temp);
            
            return factors.length % 2 === 0 ? 1 : -1;
        }
        
        // Check if number is prime (cached)
        function isPrime(n) {
            if (primeCache.size > 0) return primeCache.has(n);
            // Fallback if cache not built
            if (n < 2) return false;
            if (n === 2) return true;
            if (n % 2 === 0) return false;
            for (let i = 3; i * i <= n; i += 2) {
                if (n % i === 0) return false;
            }
            return true;
        }
        
        // Build prime cache using Sieve of Eratosthenes
        function cachePrimes(maxN) {
            primeCache.clear();
            if (maxN < 2) return;
            
            const sieve = new Array(maxN + 1).fill(true);
            sieve[0] = sieve[1] = false;
            
            for (let i = 2; i * i <= maxN; i++) {
                if (sieve[i]) {
                    for (let j = i * i; j <= maxN; j += i) {
                        sieve[j] = false;
                    }
                }
            }
            
            for (let i = 2; i <= maxN; i++) {
                if (sieve[i]) primeCache.add(i);
            }
        }
        
        // Generate Farey sequence of order n
        function generateFarey(n) {
            const farey = [];
            for (let b = 1; b <= n; b++) {
                for (let a = 0; a <= b; a++) {
                    if (gcd(a, b) === 1) {
                        farey.push({num: a, den: b, value: a / b});
                    }
                }
            }
            farey.sort((x, y) => x.value - y.value);
            return farey;
        }
        
        // Color schemes
        const colorSchemes = {
            classic: (isCoprime, gcdVal) => isCoprime ? '#70ff70' : '#4060b0',
            heatmap: (isCoprime, gcdVal) => {
                if (isCoprime) return '#ffff00';
                const intensity = Math.min(gcdVal / 10, 1);
                const r = Math.floor(255 * intensity);
                const b = Math.floor(255 * (1 - intensity));
                return `rgb(${r},0,${b})`;
            },
            monochrome: (isCoprime, gcdVal) => isCoprime ? '#ffffff' : '#202020',
            rainbow: (isCoprime, gcdVal) => {
                if (isCoprime) return '#ffffff';
                const hue = (gcdVal * 30) % 360;
                return `hsl(${hue}, 70%, 50%)`;
            },
            neon: (isCoprime, gcdVal) => isCoprime ? '#00ffff' : '#ff00ff',
            colorblind: (isCoprime, gcdVal) => isCoprime ? '#ff8c00' : '#0080ff', // Orange/Blue for deuteranopia
            highcontrast: (isCoprime, gcdVal) => isCoprime ? '#ffff00' : '#000000' // Yellow/Black
        };
        
        // Global state
        let latticeData = null;
        let currentStats = null;
        let latticeGrid = null; // For fast lookup by coordinates
        let currentN = 0;
        let currentPixelsPerUnit = 0;
        let baseCanvas = null; // Store the base visualization without zoom/labels
        let userPresets = {}; // Store user-defined presets
        let primeCache = new Set(); // Cache prime numbers
        let isDragging = false;
        let dragStartX = 0;
        let dragStartY = 0;
        let dragStartPanX = 0;
        let dragStartPanY = 0;
        
        // Keyboard shortcuts help
        let showingHelp = false;
        
        // Load presets from localStorage
        try {
            const saved = localStorage.getItem('coprimePresets');
            if (saved) userPresets = JSON.parse(saved);
        } catch (e) {
            console.log('Could not load saved presets');
        }
        
        // UI Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const gridSizeSlider = document.getElementById('gridSize');
        const gridSizeInput = document.getElementById('gridSizeInput');
        const gridSizeValue = document.getElementById('gridSizeValue');
        const pointSizeSlider = document.getElementById('pointSize');
        const pointSizeValue = document.getElementById('pointSizeValue');
        const circleRadiusSlider = document.getElementById('circleRadius');
        const circleRadiusValue = document.getElementById('circleRadiusValue');
        const showCircleCheck = document.getElementById('showCircle');
        const resolutionSelect = document.getElementById('resolution');
        const colorSchemeSelect = document.getElementById('colorScheme');
        
        // Label controls
        const showLabelsCheck = document.getElementById('showLabels');
        const labelTypeSelect = document.getElementById('labelType');
        const labelThresholdSlider = document.getElementById('labelThreshold');
        const labelThresholdValue = document.getElementById('labelThresholdValue');
        const labelFontSizeSlider = document.getElementById('labelFontSize');
        const labelFontSizeValue = document.getElementById('labelFontSizeValue');
        
        // Zoom controls
        const zoomLevelSlider = document.getElementById('zoomLevel');
        const zoomLevelValue = document.getElementById('zoomLevelValue');
        const panXSlider = document.getElementById('panX');
        const panXInput = document.getElementById('panXInput');
        const panXValue = document.getElementById('panXValue');
        const panYSlider = document.getElementById('panY');
        const panYInput = document.getElementById('panYInput');
        const panYValue = document.getElementById('panYValue');
        
        // Sync input and slider
        gridSizeSlider.oninput = () => {
            gridSizeValue.textContent = gridSizeSlider.value;
            gridSizeInput.value = gridSizeSlider.value;
        };
        gridSizeInput.oninput = () => {
            const val = Math.max(1, Math.min(10000, parseInt(gridSizeInput.value) || 1));
            gridSizeInput.value = val;
            gridSizeSlider.value = val;
            gridSizeValue.textContent = val;
        };
        pointSizeSlider.oninput = () => pointSizeValue.textContent = pointSizeSlider.value;
        circleRadiusSlider.oninput = () => circleRadiusValue.textContent = circleRadiusSlider.value + '%';
        
        
        // Parse fraction input like "1/2" or "-3/4" and return percentage
        function parseFractionToPercent(input) {
            input = input.trim();
            
            // Handle empty or just "0"
            if (input === '' || input === '0') return 0;
            
            // Handle plain numbers
            if (!input.includes('/')) {
                const num = parseFloat(input);
                return isNaN(num) ? 0 : Math.max(-100, Math.min(100, num));
            }
            
            // Parse fraction
            const parts = input.split('/');
            if (parts.length !== 2) return 0;
            
            const numerator = parseFloat(parts[0].trim());
            const denominator = parseFloat(parts[1].trim());
            
            if (isNaN(numerator) || isNaN(denominator) || denominator === 0) {
                return 0;
            }
            
            const percent = (numerator / denominator) * 100;
            return Math.max(-100, Math.min(100, percent));
        }
        
        // Update pan inputs
        panXInput.addEventListener('input', () => {
            const percent = parseFractionToPercent(panXInput.value);
            panXSlider.value = percent;
            panXValue.textContent = percent.toFixed(1) + '%';
            if (baseCanvas) redrawWithZoomAndLabels();
        });
        
        panYInput.addEventListener('input', () => {
            const percent = parseFractionToPercent(panYInput.value);
            panYSlider.value = percent;
            panYValue.textContent = percent.toFixed(1) + '%';
            if (baseCanvas) redrawWithZoomAndLabels();
        });
        
        // Sync slider to input
        panXSlider.addEventListener('input', () => {
            const val = parseFloat(panXSlider.value);
            panXValue.textContent = val + '%';
            panXInput.value = val;
            if (baseCanvas) redrawWithZoomAndLabels();
        });
        
        panYSlider.addEventListener('input', () => {
            const val = parseFloat(panYSlider.value);
            panYValue.textContent = val + '%';
            panYInput.value = val;
            if (baseCanvas) redrawWithZoomAndLabels();
        });
        
        labelThresholdSlider.oninput = () => {
            labelThresholdValue.textContent = labelThresholdSlider.value;
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        labelFontSizeSlider.oninput = () => {
            labelFontSizeValue.textContent = labelFontSizeSlider.value + 'px';
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        zoomLevelSlider.oninput = () => {
            zoomLevelValue.textContent = parseFloat(zoomLevelSlider.value).toFixed(1) + 'x';
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        panXSlider.oninput = () => {
            panXValue.textContent = panXSlider.value + '%';
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        panYSlider.oninput = () => {
            panYValue.textContent = panYSlider.value + '%';
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        showCircleCheck.onchange = () => {
            circleRadiusSlider.disabled = !showCircleCheck.checked;
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('showCustomLine').onchange = (e) => {
            document.getElementById('customSlope').disabled = !e.target.checked;
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('showHyperbola').onchange = (e) => {
            document.getElementById('hyperbolaK').disabled = !e.target.checked;
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('highlightModular').onchange = (e) => {
            const enabled = e.target.checked;
            document.getElementById('modulus').disabled = !enabled;
            document.getElementById('residueA').disabled = !enabled;
            document.getElementById('residueB').disabled = !enabled;
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('modulus').onchange = () => {
            const m = parseInt(document.getElementById('modulus').value);
            document.getElementById('residueA').max = m - 1;
            document.getElementById('residueB').max = m - 1;
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('showFarey').onchange = (e) => {
            document.getElementById('fareyOrder').disabled = !e.target.checked;
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('showRadialDensity').onchange = (e) => {
            document.getElementById('radialDensityCard').style.display = e.target.checked ? 'block' : 'none';
            if (e.target.checked && latticeData) plotRadialDensity();
        };
        
        document.getElementById('showAngularDist').onchange = (e) => {
            const enabled = e.target.checked;
            document.getElementById('angularSectors').disabled = !enabled;
            document.getElementById('angularDistCard').style.display = enabled ? 'block' : 'none';
            if (enabled && latticeData) plotAngularDistribution();
        };
        
        // Redraw when overlay parameters change
        document.getElementById('customSlope').onchange = () => {
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('hyperbolaK').onchange = () => {
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('residueA').onchange = () => {
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('residueB').onchange = () => {
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('fareyOrder').onchange = () => {
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('showDiagonals').onchange = () => {
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('primeFilter').onchange = () => {
            if (latticeData) generateVisualization();
        };
        
        document.getElementById('angularSectors').onchange = () => {
            if (latticeData) plotAngularDistribution();
        };
        
        circleRadiusSlider.onchange = () => {
            if (latticeData) generateVisualization();
        };
        
        showLabelsCheck.onchange = () => {
            const enabled = showLabelsCheck.checked;
            labelTypeSelect.disabled = !enabled;
            labelThresholdSlider.disabled = !enabled;
            labelFontSizeSlider.disabled = !enabled;
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        labelTypeSelect.onchange = () => {
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('resetZoom').onclick = () => {
            zoomLevelSlider.value = 1;
            panXSlider.value = 0;
            panYSlider.value = 0;
            panXInput.value = '0';
            panYInput.value = '0';
            zoomLevelValue.textContent = '1.0x';
            panXValue.textContent = '0%';
            panYValue.textContent = '0%';
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        // Generate visualization
        document.getElementById('generateBtn').onclick = generateVisualization;
        
        // Validate inputs
        function validateInputs() {
            const N = parseInt(gridSizeSlider.value);
            if (N < 1 || N > 10000) {
                alert('Grid size must be between 1 and 10000');
                return false;
            }
            return true;
        }
        
        async function generateVisualization() {
            if (!validateInputs()) return;
            
            try {
                const startTime = performance.now();
            const loading = document.getElementById('loading');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            
            loading.style.display = 'block';
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
            
            // Get parameters
            const N = parseInt(gridSizeSlider.value);
            const resolution = parseInt(resolutionSelect.value);
            const pointSize = parseInt(pointSizeSlider.value);
            const colorSchemeName = colorSchemeSelect.value;
            const colorFunc = colorSchemes[colorSchemeName];
            const showCircle = showCircleCheck.checked;
            const circleRadiusPct = parseInt(circleRadiusSlider.value) / 100;
            const showAxes = document.getElementById('showAxes').checked;
            const showGrid = document.getElementById('showGrid').checked;
            const analyzeDisc = document.getElementById('analyzeDisc').checked;
            const primeFilter = document.getElementById('primeFilter').checked;
            
            // Cache primes if using prime filter
            if (primeFilter) {
                loading.textContent = 'Caching primes...';
                cachePrimes(N);
                showStatus(`‚úì Cached ${primeCache.size} primes up to ${N}`, 2000);
            }
            loading.textContent = 'Computing...';
            
            // Setup canvas
            canvas.width = resolution;
            canvas.height = resolution;
            
            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, resolution, resolution);
            
            // Calculate scaling
            const pixelsPerUnit = resolution / N;
            currentN = N;
            currentPixelsPerUnit = pixelsPerUnit;
            
            // Data structures
            latticeData = [];
            latticeGrid = {}; // For fast coordinate lookup
            let coprimeCount = 0;
            let gcdDistribution = {};
            let mobiusSum = 0;
            let mobiusOverN = 0;
            let mobiusOverN2 = 0;
            let totalPointsGenerated = 0; // Track actual points generated
            
            const R = N * circleRadiusPct / 2;
            let discTotal = 0;
            let discCoprime = 0;
            const centerX = N / 2;
            const centerY = N / 2;
            
            // Generate and draw points
            for (let a = 0; a < N; a++) {
                for (let b = 0; b < N; b++) {
                    const gcdVal = gcd(a, b);
                    const isCoprime = gcdVal === 1;
                    
                    // Apply prime filter if enabled
                    if (primeFilter && !isPrime(a) && !isPrime(b)) {
                        continue; // Skip if neither a nor b is prime
                    }
                    
                    totalPointsGenerated++; // Count actual points
                    
                    const pointData = {a, b, gcd: gcdVal, coprime: isCoprime};
                    latticeData.push(pointData);
                    
                    // Store in grid for fast lookup
                    latticeGrid[`${a},${b}`] = pointData;
                    
                    if (isCoprime) coprimeCount++;
                    
                    gcdDistribution[gcdVal] = (gcdDistribution[gcdVal] || 0) + 1;
                    
                    // Draw point
                    const x = a * pixelsPerUnit;
                    const y = (N - b - 1) * pixelsPerUnit;
                    
                    ctx.fillStyle = colorFunc(isCoprime, gcdVal);
                    ctx.fillRect(x, y, pointSize, pointSize);
                    
                    // Disc analysis
                    if (analyzeDisc && showCircle) {
                        const dx = a - centerX;
                        const dy = b - centerY;
                        const distSq = dx * dx + dy * dy;
                        
                        if (distSq <= R * R) {
                            discTotal++;
                            if (isCoprime) discCoprime++;
                        }
                    }
                }
                
                // Update progress
                const progress = ((a + 1) / N) * 100;
                progressFill.style.width = progress + '%';
                
                if (a % 50 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // Calculate M√∂bius statistics
            for (let n = 1; n <= N; n++) {
                const mu = mobius(n);
                mobiusSum += mu;
                mobiusOverN += mu / n;
                mobiusOverN2 += mu / (n * n);
            }
            
            // Draw overlays
            if (showGrid) {
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 0.5;
                const gridStep = Math.max(1, Math.floor(N / 20));
                for (let i = 0; i <= N; i += gridStep) {
                    ctx.beginPath();
                    ctx.moveTo(i * pixelsPerUnit, 0);
                    ctx.lineTo(i * pixelsPerUnit, resolution);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, i * pixelsPerUnit);
                    ctx.lineTo(resolution, i * pixelsPerUnit);
                    ctx.stroke();
                }
            }
            
            if (showCircle) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(
                    centerX * pixelsPerUnit,
                    (N - centerY) * pixelsPerUnit,
                    R * pixelsPerUnit,
                    0,
                    2 * Math.PI
                );
                ctx.stroke();
            }
            
            if (showAxes) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                
                // X axis
                ctx.beginPath();
                ctx.moveTo(0, (N / 2) * pixelsPerUnit);
                ctx.lineTo(resolution, (N / 2) * pixelsPerUnit);
                ctx.stroke();
                
                // Y axis
                ctx.beginPath();
                ctx.moveTo((N / 2) * pixelsPerUnit, 0);
                ctx.lineTo((N / 2) * pixelsPerUnit, resolution);
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#ffffff';
                ctx.font = `${Math.max(12, resolution / 200)}px Arial`;
                ctx.fillText('a', resolution - 30, (N / 2) * pixelsPerUnit - 10);
                ctx.fillText('b', (N / 2) * pixelsPerUnit + 10, 30);
            }
            
            const endTime = performance.now();
            const genTime = ((endTime - startTime) / 1000).toFixed(2);
            
            // Calculate statistics using actual points generated
            const totalPoints = totalPointsGenerated;
            const coprimeDensity = coprimeCount / totalPoints;
            const theoretical = 6 / (Math.PI * Math.PI);
            const relativeError = ((coprimeDensity - theoretical) / theoretical * 100).toFixed(3);
            
            const discExpected = theoretical * Math.PI * R * R;
            const discError = discCoprime - discExpected;
            const errorRatio = Math.abs(discError) / Math.sqrt(R);
            
            currentStats = {
                N,
                totalPoints,
                coprimeCount,
                coprimeDensity,
                theoretical,
                relativeError,
                R,
                discTotal,
                discCoprime,
                discExpected,
                discError,
                errorRatio,
                mobiusSum,
                mobiusOverN,
                mobiusOverN2,
                gcdDistribution,
                genTime,
                resolution,
                pointSize,
                colorScheme: colorSchemeName
            };
            
            updateStatistics();
            
            // Screen reader announcement
            const ariaLive = document.getElementById('ariaLive');
            if (ariaLive) {
                ariaLive.textContent = `Visualization complete. ${coprimeCount} coprime points out of ${totalPoints} total. Density: ${coprimeDensity.toFixed(4)}.`;
            }
            
            // Generate plots if enabled
            if (document.getElementById('showRadialDensity').checked) {
                plotRadialDensity();
            }
            if (document.getElementById('showAngularDist').checked) {
                plotAngularDistribution();
            }
            
            loading.style.display = 'none';
            progressBar.style.display = 'none';
            
            // Save base canvas for zoom/label operations
            baseCanvas = document.createElement('canvas');
            baseCanvas.width = canvas.width;
            baseCanvas.height = canvas.height;
            baseCanvas.getContext('2d').drawImage(canvas, 0, 0);
        } catch (error) {
            console.error('Error generating visualization:', error);
            loading.style.display = 'none';
            progressBar.style.display = 'none';
            showStatus('‚ùå Error generating visualization. Try a smaller grid size.', 5000);
            alert('An error occurred while generating the visualization. Please try a smaller grid size or refresh the page.');
        }
        }
        
        function redrawWithZoomAndLabels() {
            if (!baseCanvas) return;
            
            const zoom = parseFloat(zoomLevelSlider.value);
            const panXPct = parseFloat(panXSlider.value) / 100;
            const panYPct = parseFloat(panYSlider.value) / 100;
            
            // Clear and setup canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply zoom and pan transformations
            ctx.save();
            
            // Translate to center, apply zoom, then pan
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-canvas.width / 2 - (panXPct * canvas.width), -canvas.height / 2 - (panYPct * canvas.height));
            
            // Draw the base visualization
            ctx.drawImage(baseCanvas, 0, 0);
            
            ctx.restore();
            
            // Add mathematical overlays AFTER restoring context
            drawMathematicalOverlays();
            
            // Add labels if enabled
            if (showLabelsCheck.checked) {
                addLabels(zoom, panXPct, panYPct);
            }
        }
        
        function drawMathematicalOverlays() {
            const zoom = parseFloat(zoomLevelSlider.value);
            const panXPct = parseFloat(panXSlider.value) / 100;
            const panYPct = parseFloat(panYSlider.value) / 100;
            
            ctx.save();
            
            // Apply same zoom and pan transformations
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-canvas.width / 2 - (panXPct * canvas.width), -canvas.height / 2 - (panYPct * canvas.height));
            
            // Draw diagonals
            if (document.getElementById('showDiagonals').checked) {
                ctx.strokeStyle = '#ffff00';
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([10 / zoom, 5 / zoom]);
                
                // y = x diagonal
                ctx.beginPath();
                ctx.moveTo(0, canvas.height);
                ctx.lineTo(canvas.width, 0);
                ctx.stroke();
                
                // y = -x diagonal (mirrored)
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(canvas.width, canvas.height);
                ctx.stroke();
                
                ctx.setLineDash([]);
            }
            
            // Draw custom line y = mx
            if (document.getElementById('showCustomLine').checked) {
                const m = parseFloat(document.getElementById('customSlope').value);
                ctx.strokeStyle = '#ff00ff';
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([10 / zoom, 5 / zoom]);
                
                ctx.beginPath();
                // Line from origin through the grid
                const x1 = 0;
                const y1 = canvas.height;
                const x2 = canvas.width;
                const y2 = canvas.height - (m * currentN * currentPixelsPerUnit);
                
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
                
                ctx.setLineDash([]);
                
                // Label
                ctx.fillStyle = '#ff00ff';
                ctx.font = `${16 / zoom}px Arial`;
                ctx.fillText(`y=${m}x`, x2 - 80 / zoom, y2 - 10 / zoom);
            }
            
            // Draw hyperbola xy = k
            if (document.getElementById('showHyperbola').checked) {
                const k = parseFloat(document.getElementById('hyperbolaK').value);
                ctx.strokeStyle = '#00ffff';
                ctx.lineWidth = 2 / zoom;
                ctx.setLineDash([5 / zoom, 5 / zoom]);
                
                ctx.beginPath();
                let firstPoint = true;
                for (let a = 1; a < currentN; a += 0.5) {
                    const b = k / a;
                    if (b > 0 && b < currentN) {
                        const x = a * currentPixelsPerUnit;
                        const y = (currentN - b) * currentPixelsPerUnit;
                        
                        if (firstPoint) {
                            ctx.moveTo(x, y);
                            firstPoint = false;
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                }
                ctx.stroke();
                
                ctx.setLineDash([]);
                
                // Label
                ctx.fillStyle = '#00ffff';
                ctx.font = `${16 / zoom}px Arial`;
                const labelX = Math.min(currentN / 2, Math.sqrt(k));
                const labelB = k / labelX;
                if (labelB < currentN) {
                    const x = labelX * currentPixelsPerUnit;
                    const y = (currentN - labelB) * currentPixelsPerUnit;
                    ctx.fillText(`xy=${k}`, x + 10 / zoom, y - 10 / zoom);
                }
            }
            
            // Draw Farey sequence
            if (document.getElementById('showFarey').checked) {
                const fareyN = parseInt(document.getElementById('fareyOrder').value);
                const fareySeq = generateFarey(fareyN);
                
                ctx.strokeStyle = '#ffa500';
                ctx.lineWidth = 1.5 / zoom;
                
                fareySeq.forEach(frac => {
                    if (frac.den <= currentN && frac.num <= currentN) {
                        const x = frac.num * currentPixelsPerUnit;
                        const y = (currentN - frac.den) * currentPixelsPerUnit;
                        
                        // Draw small circle at Farey point
                        ctx.beginPath();
                        ctx.arc(x, y, 4 / zoom, 0, 2 * Math.PI);
                        ctx.stroke();
                        
                        // Draw line from origin to point
                        ctx.beginPath();
                        ctx.moveTo(0, canvas.height);
                        ctx.lineTo(x, y);
                        ctx.stroke();
                    }
                });
            }
            
            // Highlight modular classes
            if (document.getElementById('highlightModular').checked) {
                const m = parseInt(document.getElementById('modulus').value);
                const resA = parseInt(document.getElementById('residueA').value);
                const resB = parseInt(document.getElementById('residueB').value);
                
                ctx.fillStyle = 'rgba(255, 255, 0, 0.3)';
                
                for (let a = 0; a < currentN; a++) {
                    for (let b = 0; b < currentN; b++) {
                        if (a % m === resA && b % m === resB) {
                            const x = a * currentPixelsPerUnit;
                            const y = (currentN - b - 1) * currentPixelsPerUnit;
                            ctx.fillRect(x, y, currentPixelsPerUnit, currentPixelsPerUnit);
                        }
                    }
                }
            }
            
            ctx.restore();
        }
        
        function plotRadialDensity() {
            if (!latticeData || latticeData.length === 0) return;
            
            const canvas = document.getElementById('radialCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            
            // Calculate density at different radii
            const centerX = currentN / 2;
            const centerY = currentN / 2;
            const maxR = Math.sqrt(centerX * centerX + centerY * centerY);
            const numBins = 50;
            const binSize = maxR / numBins;
            
            const bins = Array(numBins).fill(0).map(() => ({total: 0, coprime: 0}));
            
            latticeData.forEach(point => {
                const dx = point.a - centerX;
                const dy = point.b - centerY;
                const r = Math.sqrt(dx * dx + dy * dy);
                const binIdx = Math.min(Math.floor(r / binSize), numBins - 1);
                
                bins[binIdx].total++;
                if (point.coprime) bins[binIdx].coprime++;
            });
            
            // Calculate densities
            const densities = bins.map(bin => bin.total > 0 ? bin.coprime / bin.total : 0);
            const theoretical = 6 / (Math.PI * Math.PI);
            
            // Draw axes
            const margin = 40;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;
            
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, height - margin);
            ctx.lineTo(width - margin, height - margin);
            ctx.stroke();
            
            // Draw theoretical line
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 2;
            ctx.setLineDash([5, 5]);
            const theoreticalY = height - margin - (theoretical * plotHeight);
            ctx.beginPath();
            ctx.moveTo(margin, theoreticalY);
            ctx.lineTo(width - margin, theoreticalY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw density curve
            ctx.strokeStyle = '#4fc3f7';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            densities.forEach((density, i) => {
                const x = margin + (i / numBins) * plotWidth;
                const y = height - margin - (density * plotHeight);
                
                if (i === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            });
            ctx.stroke();
            
            // Labels
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '12px Arial';
            ctx.fillText('Radius R', width / 2 - 30, height - 10);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Coprime Density', 0, 0);
            ctx.restore();
            
            // Legend
            ctx.fillStyle = '#4fc3f7';
            ctx.fillRect(width - 150, 20, 20, 3);
            ctx.fillStyle = '#e0e0e0';
            ctx.fillText('Observed', width - 125, 25);
            
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(width - 150, 35, 20, 3);
            ctx.fillStyle = '#e0e0e0';
            ctx.fillText('6/œÄ¬≤ ‚âà 0.608', width - 125, 40);
            
            // Y-axis values
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = (i / 5).toFixed(2);
                const y = height - margin - (i / 5) * plotHeight;
                ctx.fillText(val, margin - 5, y + 4);
            }
            
            // X-axis values
            ctx.textAlign = 'center';
            for (let i = 0; i <= 5; i++) {
                const val = Math.round((i / 5) * maxR);
                const x = margin + (i / 5) * plotWidth;
                ctx.fillText(val, x, height - margin + 15);
            }
        }
        
        function plotAngularDistribution() {
            if (!latticeData || latticeData.length === 0) return;
            
            const canvas = document.getElementById('angularCanvas');
            const ctx = canvas.getContext('2d');
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, width, height);
            
            const numSectors = parseInt(document.getElementById('angularSectors').value);
            const sectorSize = 360 / numSectors;
            
            const sectors = Array(numSectors).fill(0).map(() => ({total: 0, coprime: 0}));
            
            // Count points in each angular sector
            const centerX = currentN / 2;
            const centerY = currentN / 2;
            
            latticeData.forEach(point => {
                const dx = point.a - centerX;
                const dy = point.b - centerY;
                
                if (dx === 0 && dy === 0) return;
                
                let angle = Math.atan2(dy, dx) * (180 / Math.PI);
                if (angle < 0) angle += 360;
                
                const sectorIdx = Math.floor(angle / sectorSize) % numSectors;
                
                sectors[sectorIdx].total++;
                if (point.coprime) sectors[sectorIdx].coprime++;
            });
            
            // Calculate densities
            const densities = sectors.map(s => s.total > 0 ? s.coprime / s.total : 0);
            const theoretical = 6 / (Math.PI * Math.PI);
            
            // Draw bar chart
            const margin = 40;
            const plotWidth = width - 2 * margin;
            const plotHeight = height - 2 * margin;
            const barWidth = plotWidth / numSectors;
            
            // Draw axes
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(margin, margin);
            ctx.lineTo(margin, height - margin);
            ctx.lineTo(width - margin, height - margin);
            ctx.stroke();
            
            // Draw theoretical line
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            const theoreticalY = height - margin - (theoretical * plotHeight);
            ctx.beginPath();
            ctx.moveTo(margin, theoreticalY);
            ctx.lineTo(width - margin, theoreticalY);
            ctx.stroke();
            ctx.setLineDash([]);
            
            // Draw bars
            densities.forEach((density, i) => {
                const x = margin + i * barWidth;
                const barHeight = density * plotHeight;
                const y = height - margin - barHeight;
                
                ctx.fillStyle = '#4fc3f7';
                ctx.fillRect(x + 1, y, barWidth - 2, barHeight);
            });
            
            // Labels
            ctx.fillStyle = '#e0e0e0';
            ctx.font = '12px Arial';
            ctx.fillText('Angle (degrees)', width / 2 - 40, height - 10);
            
            ctx.save();
            ctx.translate(15, height / 2);
            ctx.rotate(-Math.PI / 2);
            ctx.fillText('Coprime Density', 0, 0);
            ctx.restore();
            
            // Legend
            ctx.fillStyle = '#4fc3f7';
            ctx.fillRect(width - 150, 20, 20, 10);
            ctx.fillStyle = '#e0e0e0';
            ctx.fillText('Observed', width - 125, 28);
            
            ctx.fillStyle = '#ff0000';
            ctx.fillRect(width - 150, 35, 20, 3);
            ctx.fillText('6/œÄ¬≤ ‚âà 0.608', width - 125, 40);
            
            // Y-axis values
            ctx.font = '10px Arial';
            ctx.textAlign = 'right';
            for (let i = 0; i <= 5; i++) {
                const val = (i / 5).toFixed(2);
                const y = height - margin - (i / 5) * plotHeight;
                ctx.fillText(val, margin - 5, y + 4);
            }
            
            // X-axis values (angle labels)
            ctx.textAlign = 'center';
            for (let i = 0; i < Math.min(numSectors, 8); i++) {
                const angle = Math.round((i / numSectors) * 360);
                const x = margin + (i / numSectors) * plotWidth;
                ctx.fillText(angle + '¬∞', x, height - margin + 15);
            }
        }
        
        function addLabels(zoom, panXPct, panYPct) {
            const labelType = labelTypeSelect.value;
            const threshold = parseInt(labelThresholdSlider.value);
            const fontSize = parseInt(labelFontSizeSlider.value);
            
            if (!latticeData || latticeData.length === 0) return;
            
            // Determine which points are visible and should be labeled
            const centerX = currentN / 2;
            const centerY = currentN / 2;
            
            // Calculate visible region based on zoom and pan
            const visibleWidth = currentN / zoom;
            const visibleHeight = currentN / zoom;
            const viewCenterX = centerX + panXPct * currentN;
            const viewCenterY = centerY + panYPct * currentN;
            
            const minA = Math.max(0, Math.floor(viewCenterX - visibleWidth / 2));
            const maxA = Math.min(currentN - 1, Math.ceil(viewCenterX + visibleWidth / 2));
            const minB = Math.max(0, Math.floor(viewCenterY - visibleHeight / 2));
            const maxB = Math.min(currentN - 1, Math.ceil(viewCenterY + visibleHeight / 2));
            
            // Filter points in visible region
            let visiblePoints = [];
            for (let a = minA; a <= maxA; a++) {
                for (let b = minB; b <= maxB; b++) {
                    const key = `${a},${b}`;
                    if (latticeGrid[key]) {
                        visiblePoints.push(latticeGrid[key]);
                    }
                }
            }
            
            // Limit to threshold
            if (visiblePoints.length > threshold) {
                // Sample evenly or prioritize coprime points
                const step = Math.ceil(visiblePoints.length / threshold);
                visiblePoints = visiblePoints.filter((_, idx) => idx % step === 0);
            }
            
            // Draw labels
            ctx.save();
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            visiblePoints.forEach(point => {
                const {a, b, gcd: gcdVal} = point;
                
                let labelText = '';
                switch (labelType) {
                    case 'gcd':
                        labelText = gcdVal.toString();
                        break;
                    case 'fraction':
                        labelText = b === 0 ? '‚àû' : `${a}/${b}`;
                        break;
                    case 'coordinates':
                        labelText = `${a},${b}`;
                        break;
                    case 'reduced':
                        const frac = simplifyFraction(a, b);
                        labelText = `${frac.num}/${frac.den}`;
                        break;
                }
                
                // Calculate screen position with zoom and pan
                const x = a * currentPixelsPerUnit;
                const y = (currentN - b - 1) * currentPixelsPerUnit;
                
                // Apply transformations
                const screenX = (x - canvas.width / 2 - (panXPct * canvas.width)) * zoom + canvas.width / 2;
                const screenY = (y - canvas.height / 2 - (panYPct * canvas.height)) * zoom + canvas.height / 2;
                
                // Draw label with background
                const metrics = ctx.measureText(labelText);
                const padding = 3;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(
                    screenX - metrics.width / 2 - padding,
                    screenY - fontSize / 2 - padding,
                    metrics.width + padding * 2,
                    fontSize + padding * 2
                );
                
                ctx.fillStyle = point.coprime ? '#70ff70' : '#4fc3f7';
                ctx.fillText(labelText, screenX, screenY);
            });
            
            ctx.restore();
        }
        
        // Point inspection on click
        canvas.addEventListener('click', (event) => {
            if (isDragging) return; // Don't inspect if we were dragging
            
            if (!latticeGrid || currentN === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const canvasX = (event.clientX - rect.left) * scaleX;
            const canvasY = (event.clientY - rect.top) * scaleY;
            
            // Account for zoom and pan
            const zoom = parseFloat(zoomLevelSlider.value);
            const panXPct = parseFloat(panXSlider.value) / 100;
            const panYPct = parseFloat(panYSlider.value) / 100;
            
            // Reverse transformation
            const unzoomedX = (canvasX - canvas.width / 2) / zoom + canvas.width / 2 + (panXPct * canvas.width);
            const unzoomedY = (canvasY - canvas.height / 2) / zoom + canvas.height / 2 + (panYPct * canvas.height);
            
            // Convert to lattice coordinates
            const a = Math.floor(unzoomedX / currentPixelsPerUnit);
            const b = currentN - Math.floor(unzoomedY / currentPixelsPerUnit) - 1;
            
            // Check bounds
            if (a < 0 || a >= currentN || b < 0 || b >= currentN) {
                return;
            }
            
            // Get point data
            const key = `${a},${b}`;
            const point = latticeGrid[key];
            
            if (point) {
                displayPointInfo(point);
                highlightPoint(a, b);
            }
        });
        
        function displayPointInfo(point) {
            const {a, b, gcd: gcdVal, coprime} = point;
            
            // Calculate properties
            const frac = simplifyFraction(a, b);
            const r = polarRadius(a, b);
            const theta = angleDegrees(a, b);
            const thetaRad = theta * (Math.PI / 180);
            
            // Modular properties
            const mod2_a = a % 2;
            const mod2_b = b % 2;
            const mod3_a = a % 3;
            const mod3_b = b % 3;
            const mod5_a = a % 5;
            const mod5_b = b % 5;
            
            const inspector = document.getElementById('pointInspector');
            inspector.className = 'point-inspector';
            
            inspector.innerHTML = `
                <div style="margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px solid #444;">
                    <div style="font-size: 16px; font-weight: bold; color: #4fc3f7;">Point (${a}, ${b})</div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
                    <div>
                        <div style="color: #888;">Cartesian (a, b)</div>
                        <div style="color: #4fc3f7; font-weight: bold;">(${a}, ${b})</div>
                    </div>
                    <div>
                        <div style="color: #888;">GCD(a, b)</div>
                        <div style="color: ${coprime ? '#70ff70' : '#ff7070'}; font-weight: bold;">${gcdVal} ${coprime ? '‚òÖ' : ''}</div>
                    </div>
                    
                    <div>
                        <div style="color: #888;">Coprime</div>
                        <div style="color: ${coprime ? '#70ff70' : '#ff7070'}; font-weight: bold;">${coprime ? 'Yes' : 'No'}</div>
                    </div>
                    <div>
                        <div style="color: #888;">Simplified Ratio</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${frac.num}/${frac.den}</div>
                    </div>
                    
                    <div>
                        <div style="color: #888;">Radius r</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${r.toFixed(4)}</div>
                    </div>
                    <div>
                        <div style="color: #888;">Angle Œ∏</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${theta.toFixed(2)}¬∞</div>
                    </div>
                    
                    <div>
                        <div style="color: #888;">Œ∏ (radians)</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${thetaRad.toFixed(4)}</div>
                    </div>
                    <div>
                        <div style="color: #888;">Polar (r, Œ∏)</div>
                        <div style="color: #4fc3f7; font-weight: bold;">(${r.toFixed(2)}, ${theta.toFixed(1)}¬∞)</div>
                    </div>
                </div>
                
                <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #444;">
                    <div style="color: #888; font-size: 11px; margin-bottom: 6px;">Modular Properties</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; font-size: 11px;">
                        <div>
                            <div style="color: #888;">mod 2</div>
                            <div style="color: #90caf9;">(${mod2_a}, ${mod2_b})</div>
                        </div>
                        <div>
                            <div style="color: #888;">mod 3</div>
                            <div style="color: #90caf9;">(${mod3_a}, ${mod3_b})</div>
                        </div>
                        <div>
                            <div style="color: #888;">mod 5</div>
                            <div style="color: #90caf9;">(${mod5_a}, ${mod5_b})</div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #444;">
                    <div style="color: #888; font-size: 11px; margin-bottom: 6px;">Additional Info</div>
                    <div style="font-size: 11px; line-height: 1.6;">
                        <div style="color: #b0b0b0;">a¬≤ + b¬≤ = <span style="color: #4fc3f7;">${a*a + b*b}</span></div>
                        <div style="color: #b0b0b0;">Distance from origin: <span style="color: #4fc3f7;">${r.toFixed(4)}</span></div>
                        ${gcdVal > 1 ? `<div style="color: #b0b0b0;">Reduced point: <span style="color: #4fc3f7;">(${frac.num}, ${frac.den})</span></div>` : ''}
                    </div>
                </div>
            `;
        }
        
        function highlightPoint(a, b) {
            const highlight = document.getElementById('pointHighlight');
            const rect = canvas.getBoundingClientRect();
            
            const zoom = parseFloat(zoomLevelSlider.value);
            const panXPct = parseFloat(panXSlider.value) / 100;
            const panYPct = parseFloat(panYSlider.value) / 100;
            
            const x = a * currentPixelsPerUnit;
            const y = (currentN - b - 1) * currentPixelsPerUnit;
            
            // Apply zoom and pan to highlight position
            const screenX = (x - canvas.width / 2 - (panXPct * canvas.width)) * zoom + canvas.width / 2;
            const screenY = (y - canvas.height / 2 - (panYPct * canvas.height)) * zoom + canvas.height / 2;
            
            // Scale to display size
            const displayScale = rect.width / canvas.width;
            const displayX = screenX * displayScale;
            const displayY = screenY * displayScale;
            
            highlight.style.left = displayX + 'px';
            highlight.style.top = displayY + 'px';
            highlight.style.width = Math.max(20, currentPixelsPerUnit * displayScale * zoom * 2) + 'px';
            highlight.style.height = Math.max(20, currentPixelsPerUnit * displayScale * zoom * 2) + 'px';
            highlight.style.display = 'block';
            
            // Fade out after 3 seconds (extended from 2)
            setTimeout(() => {
                highlight.style.display = 'none';
            }, 3000);
        }
        
        // Drag to pan
        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            dragStartX = e.clientX;
            dragStartY = e.clientY;
            dragStartPanX = parseFloat(panXSlider.value);
            dragStartPanY = parseFloat(panYSlider.value);
            canvas.style.cursor = 'grabbing';
        });
        
        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) {
                // Show hover tooltip
                if (latticeGrid && currentN > 0 && !showingHelp) {
                    showHoverTooltip(e);
                }
                return;
            }
            
            const rect = canvas.getBoundingClientRect();
            const dx = (e.clientX - dragStartX) / rect.width * 100;
            const dy = (e.clientY - dragStartY) / rect.height * 100;
            
            const newPanX = Math.max(-100, Math.min(100, dragStartPanX + dx));
            const newPanY = Math.max(-100, Math.min(100, dragStartPanY - dy)); // Inverted Y
            
            panXSlider.value = newPanX;
            panYSlider.value = newPanY;
            panXInput.value = newPanX.toFixed(1);
            panYInput.value = newPanY.toFixed(1);
            panXValue.textContent = newPanX.toFixed(1) + '%';
            panYValue.textContent = newPanY.toFixed(1) + '%';
            
            if (baseCanvas) redrawWithZoomAndLabels();
        });
        
        canvas.addEventListener('mouseup', () => {
            if (isDragging) {
                setTimeout(() => { isDragging = false; }, 100); // Delay to prevent click event
            }
            canvas.style.cursor = 'grab';
        });
        
        canvas.addEventListener('mouseleave', () => {
            isDragging = false;
            canvas.style.cursor = 'grab';
            document.getElementById('tooltip').style.display = 'none';
        });
        
        // Mouse wheel zoom
        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            
            const delta = e.deltaY > 0 ? -0.5 : 0.5;
            const newZoom = Math.max(1, Math.min(20, parseFloat(zoomLevelSlider.value) + delta));
            
            zoomLevelSlider.value = newZoom;
            zoomLevelValue.textContent = newZoom.toFixed(1) + 'x';
            
            if (baseCanvas) redrawWithZoomAndLabels();
        }, { passive: false });
        
        // Hover tooltip
        function showHoverTooltip(event) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const canvasX = (event.clientX - rect.left) * scaleX;
            const canvasY = (event.clientY - rect.top) * scaleY;
            
            // Account for zoom and pan
            const zoom = parseFloat(zoomLevelSlider.value);
            const panXPct = parseFloat(panXSlider.value) / 100;
            const panYPct = parseFloat(panYSlider.value) / 100;
            
            const unzoomedX = (canvasX - canvas.width / 2) / zoom + canvas.width / 2 + (panXPct * canvas.width);
            const unzoomedY = (canvasY - canvas.height / 2) / zoom + canvas.height / 2 + (panYPct * canvas.height);
            
            const a = Math.floor(unzoomedX / currentPixelsPerUnit);
            const b = currentN - Math.floor(unzoomedY / currentPixelsPerUnit) - 1;
            
            if (a < 0 || a >= currentN || b < 0 || b >= currentN) {
                document.getElementById('tooltip').style.display = 'none';
                return;
            }
            
            const key = `${a},${b}`;
            const point = latticeGrid[key];
            
            if (point) {
                const tooltip = document.getElementById('tooltip');
                tooltip.innerHTML = `(${a}, ${b}) | GCD: ${point.gcd} | ${point.coprime ? '‚úì Coprime' : '‚úó Not coprime'}`;
                tooltip.style.left = (event.clientX + 15) + 'px';
                tooltip.style.top = (event.clientY + 15) + 'px';
                tooltip.style.display = 'block';
            } else {
                document.getElementById('tooltip').style.display = 'none';
            }
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Ignore if typing in input field
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'SELECT' || e.target.tagName === 'TEXTAREA') {
                return;
            }
            
            const key = e.key.toLowerCase();
            const shift = e.shiftKey;
            const ctrl = e.ctrlKey || e.metaKey;
            
            // Help toggle
            if (key === '?' || key === '/') {
                e.preventDefault();
                toggleHelp();
                return;
            }
            
            // Close help with Escape
            if (key === 'escape') {
                document.getElementById('keyboardHelp').classList.remove('show');
                return;
            }
            
            // Copy stats
            if (ctrl && key === 'c' && currentStats) {
                e.preventDefault();
                document.getElementById('copyStats').click();
                return;
            }
            
            // Space to regenerate
            if (key === ' ') {
                e.preventDefault();
                generateVisualization();
                return;
            }
            
            // Toggle controls
            if (key === 'g') {
                e.preventDefault();
                document.getElementById('showGrid').checked = !document.getElementById('showGrid').checked;
                if (baseCanvas) redrawWithZoomAndLabels();
            }
            if (key === 'a') {
                e.preventDefault();
                document.getElementById('showAxes').checked = !document.getElementById('showAxes').checked;
                if (baseCanvas) redrawWithZoomAndLabels();
            }
            if (key === 'c') {
                e.preventDefault();
                const check = showCircleCheck;
                check.checked = !check.checked;
                circleRadiusSlider.disabled = !check.checked;
                if (baseCanvas) redrawWithZoomAndLabels();
            }
            if (key === 'd') {
                e.preventDefault();
                document.getElementById('showDiagonals').checked = !document.getElementById('showDiagonals').checked;
                if (baseCanvas) redrawWithZoomAndLabels();
            }
            if (key === 'f') {
                e.preventDefault();
                const check = document.getElementById('showFarey');
                check.checked = !check.checked;
                document.getElementById('fareyOrder').disabled = !check.checked;
                if (baseCanvas) redrawWithZoomAndLabels();
            }
            if (key === 'p') {
                e.preventDefault();
                document.getElementById('primeFilter').checked = !document.getElementById('primeFilter').checked;
                generateVisualization();
            }
            if (key === 'r') {
                e.preventDefault();
                const check = document.getElementById('showRadialDensity');
                check.checked = !check.checked;
                document.getElementById('radialDensityCard').style.display = check.checked ? 'block' : 'none';
                if (check.checked && latticeData) plotRadialDensity();
            }
            if (key === 'l') {
                e.preventDefault();
                const check = showLabelsCheck;
                check.checked = !check.checked;
                const enabled = check.checked;
                labelTypeSelect.disabled = !enabled;
                labelThresholdSlider.disabled = !enabled;
                labelFontSizeSlider.disabled = !enabled;
                if (baseCanvas) redrawWithZoomAndLabels();
            }
            
            // Arrow keys for pan
            if (key.startsWith('arrow')) {
                e.preventDefault();
                const step = shift ? 1 : 5;
                
                if (key === 'arrowup') {
                    panYSlider.value = Math.max(-100, parseFloat(panYSlider.value) - step);
                } else if (key === 'arrowdown') {
                    panYSlider.value = Math.min(100, parseFloat(panYSlider.value) + step);
                } else if (key === 'arrowleft') {
                    panXSlider.value = Math.max(-100, parseFloat(panXSlider.value) - step);
                } else if (key === 'arrowright') {
                    panXSlider.value = Math.min(100, parseFloat(panXSlider.value) + step);
                }
                
                panXInput.value = panXSlider.value;
                panYInput.value = panYSlider.value;
                panXValue.textContent = panXSlider.value + '%';
                panYValue.textContent = panYSlider.value + '%';
                if (baseCanvas) redrawWithZoomAndLabels();
            }
            
            // Zoom controls
            if (key === '+' || key === '=') {
                e.preventDefault();
                const newZoom = Math.min(20, parseFloat(zoomLevelSlider.value) + 0.5);
                zoomLevelSlider.value = newZoom;
                zoomLevelValue.textContent = newZoom.toFixed(1) + 'x';
                if (baseCanvas) redrawWithZoomAndLabels();
            }
            if (key === '-' || key === '_') {
                e.preventDefault();
                const newZoom = Math.max(1, parseFloat(zoomLevelSlider.value) - 0.5);
                zoomLevelSlider.value = newZoom;
                zoomLevelValue.textContent = newZoom.toFixed(1) + 'x';
                if (baseCanvas) redrawWithZoomAndLabels();
            }
            if (key === '0') {
                e.preventDefault();
                document.getElementById('resetZoom').click();
            }
            
            // Presets 1-6
            if (['1', '2', '3', '4', '5', '6'].includes(key)) {
                e.preventDefault();
                const presets = ['prime-focus', 'rh-analysis', 'farey-explorer', 'modular-patterns', 'high-res', 'minimal'];
                const presetName = presets[parseInt(key) - 1];
                document.getElementById('presetSelect').value = presetName;
                document.getElementById('applyPreset').click();
            }
            
            // Export shortcuts
            if (key === 'e') {
                e.preventDefault();
                if (currentStats) document.getElementById('exportPNG').click();
            }
            if (key === 's') {
                e.preventDefault();
                if (currentStats) document.getElementById('exportSVG').click();
            }
            if (key === 'j') {
                e.preventDefault();
                if (currentStats) document.getElementById('exportStats').click();
            }
        });
        
        // Toggle help
        function toggleHelp() {
            const help = document.getElementById('keyboardHelp');
            showingHelp = !showingHelp;
            if (showingHelp) {
                help.classList.add('show');
            } else {
                help.classList.remove('show');
            }
        }
        
        document.getElementById('helpIcon').onclick = toggleHelp;
        
        // Status notification
        function showStatus(message, duration = 3000) {
            const statusBar = document.getElementById('statusBar');
            const statusText = document.getElementById('statusText');
            statusText.textContent = message;
            statusBar.classList.add('show');
            
            if (duration > 0) {
                setTimeout(() => {
                    statusBar.classList.remove('show');
                }, duration);
            }
        }
        
        function updateStatistics() {
            if (!currentStats) return;
            
            const s = currentStats;
            
            // Global stats
            document.getElementById('totalPoints').textContent = s.totalPoints.toLocaleString();
            document.getElementById('coprimePoints').textContent = s.coprimeCount.toLocaleString();
            document.getElementById('nonCoprimePoints').textContent = (s.totalPoints - s.coprimeCount).toLocaleString();
            document.getElementById('coprimeDensity').textContent = s.coprimeDensity.toFixed(6);
            document.getElementById('relativeError').textContent = s.relativeError + '%';
            
            // Disc stats
            if (document.getElementById('analyzeDisc').checked && document.getElementById('showCircle').checked) {
                document.getElementById('discRadius').textContent = s.R.toFixed(2);
                document.getElementById('discTotal').textContent = s.discTotal.toLocaleString();
                document.getElementById('discCoprime').textContent = s.discCoprime.toLocaleString();
                document.getElementById('discExpected').textContent = s.discExpected.toFixed(2);
                document.getElementById('discError').textContent = s.discError.toFixed(2);
                document.getElementById('errorRatio').textContent = s.errorRatio.toFixed(4);
                document.getElementById('errorLog').textContent = Math.log10(Math.abs(s.discError)).toFixed(4);
            } else {
                document.getElementById('discRadius').textContent = 'N/A';
                document.getElementById('discTotal').textContent = 'N/A';
                document.getElementById('discCoprime').textContent = 'N/A';
                document.getElementById('discExpected').textContent = 'N/A';
                document.getElementById('discError').textContent = 'N/A';
                document.getElementById('errorRatio').textContent = 'N/A';
                document.getElementById('errorLog').textContent = 'N/A';
            }
            
            // M√∂bius stats
            document.getElementById('mobiusSum').textContent = s.mobiusSum;
            document.getElementById('mobiusRatio').textContent = (Math.abs(s.mobiusSum) / Math.sqrt(s.N)).toFixed(4);
            document.getElementById('mobiusNormalized').textContent = s.mobiusOverN.toFixed(6);
            document.getElementById('mobiusSquared').textContent = s.mobiusOverN2.toFixed(6);
            document.getElementById('gcdCount').textContent = Object.keys(s.gcdDistribution).length;
            
            // Compute stats
            document.getElementById('dimensions').textContent = `${s.N} √ó ${s.N}`;
            document.getElementById('canvasSize').textContent = `${s.resolution} √ó ${s.resolution}`;
            document.getElementById('pointSizeStat').textContent = s.pointSize + 'px';
            document.getElementById('totalPixels').textContent = (s.resolution * s.resolution).toLocaleString();
            document.getElementById('genTime').textContent = s.genTime + 's';
            document.getElementById('memUsage').textContent = ((s.totalPoints * 16) / (1024 * 1024)).toFixed(2) + ' MB';
            document.getElementById('colorSchemeUsed').textContent = s.colorScheme;
            document.getElementById('zoomStat').textContent = parseFloat(zoomLevelSlider.value).toFixed(1) + 'x';
        }
        
        document.getElementById('exportPNG').onclick = () => {
            // Create a temporary canvas with stats overlay
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            
            // Calculate dimensions
            const vizSize = canvas.width;
            const legendWidth = 800;
            const hasRadialPlot = document.getElementById('showRadialDensity').checked;
            const hasAngularPlot = document.getElementById('showAngularDist').checked;
            
            let extraHeight = 0;
            if (hasRadialPlot) extraHeight += 320;
            if (hasAngularPlot) extraHeight += 320;
            
            exportCanvas.width = vizSize + legendWidth;
            exportCanvas.height = Math.max(vizSize, 1200 + extraHeight);
            
            // Fill background
            exportCtx.fillStyle = '#0a0a0a';
            exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
            
            // Save current pan/zoom and reset for full grid export
            const savedZoom = zoomLevelSlider.value;
            const savedPanX = panXSlider.value;
            const savedPanY = panYSlider.value;
            
            zoomLevelSlider.value = 1;
            panXSlider.value = 0;
            panYSlider.value = 0;
            
            // Redraw with full view
            if (baseCanvas) redrawWithZoomAndLabels();
            
            // Draw the full visualization
            exportCtx.drawImage(canvas, 0, 0);
            
            // Restore original view
            zoomLevelSlider.value = savedZoom;
            panXSlider.value = savedPanX;
            panYSlider.value = savedPanY;
            if (baseCanvas) redrawWithZoomAndLabels();
            
            // Draw legend background
            exportCtx.fillStyle = '#1a1a1a';
            exportCtx.fillRect(vizSize, 0, legendWidth, exportCanvas.height);
            
            // Draw legend content
            exportCtx.fillStyle = '#e0e0e0';
            exportCtx.font = 'bold 24px Arial';
            exportCtx.fillText('Statistics', vizSize + 20, 40);
            
            let yPos = 80;
            const lineHeight = 28;
            const sectionGap = 40;
            exportCtx.font = '16px Arial';
            
            // Global Statistics
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('GLOBAL STATISTICS', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            exportCtx.fillStyle = '#b0b0b0';
            const globalStats = [
                ['Total Points:', currentStats.totalPoints.toLocaleString()],
                ['Coprime Points:', currentStats.coprimeCount.toLocaleString()],
                ['Non-Coprime Points:', (currentStats.totalPoints - currentStats.coprimeCount).toLocaleString()],
                ['Coprime Density:', currentStats.coprimeDensity.toFixed(6)],
                ['Theoretical (6/œÄ¬≤):', '0.607927'],
                ['Relative Error:', currentStats.relativeError + '%']
            ];
            
            globalStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            yPos += sectionGap;
            
            // Disc Analysis (if enabled)
            if (document.getElementById('showCircle').checked) {
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.font = 'bold 18px Arial';
                exportCtx.fillText('DISC ANALYSIS (RADIUS R)', vizSize + 20, yPos);
                yPos += 30;
                
                exportCtx.font = '15px Arial';
                const discStats = [
                    ['Radius R:', currentStats.R.toFixed(2)],
                    ['Points in Disc:', currentStats.discTotal.toLocaleString()],
                    ['Coprime in Disc V(R):', currentStats.discCoprime.toLocaleString()],
                    ['Expected (6/œÄ¬≤)œÄR¬≤:', currentStats.discExpected.toFixed(2)],
                    ['Error E(R):', currentStats.discError.toFixed(2)],
                    ['|E(R)|/R^(1/2):', currentStats.errorRatio.toFixed(4)],
                    ['log‚ÇÅ‚ÇÄ|E(R)|:', Math.log10(Math.abs(currentStats.discError)).toFixed(4)]
                ];
                
                discStats.forEach(([label, value]) => {
                    exportCtx.fillStyle = '#b0b0b0';
                    exportCtx.fillText(label, vizSize + 20, yPos);
                    exportCtx.fillStyle = '#4fc3f7';
                    exportCtx.fillText(value, vizSize + 400, yPos);
                    yPos += lineHeight;
                });
                
                yPos += sectionGap;
            }
            
            // M√∂bius Analysis
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('M√ñBIUS FUNCTION', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            const mobiusStats = [
                ['M(N) = Œ£Œº(n):', currentStats.mobiusSum.toString()],
                ['|M(N)|/N^(1/2):', (Math.abs(currentStats.mobiusSum) / Math.sqrt(currentStats.N)).toFixed(4)],
                ['Œ£Œº(n)/n:', currentStats.mobiusOverN.toFixed(6)],
                ['Œ£Œº(n)/n¬≤:', currentStats.mobiusOverN2.toFixed(6)],
                ['Expected (1/Œ∂(2)):', '0.607927'],
                ['GCD Values Found:', Object.keys(currentStats.gcdDistribution).length.toString()]
            ];
            
            mobiusStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            yPos += sectionGap;
            
            // Computational Details
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('COMPUTATIONAL DETAILS', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            const computeStats = [
                ['Grid Dimensions:', `${currentStats.N} √ó ${currentStats.N}`],
                ['Canvas Size:', `${currentStats.resolution} √ó ${currentStats.resolution}`],
                ['Point Size:', currentStats.pointSize + 'px'],
                ['Generation Time:', currentStats.genTime + 's'],
                ['Memory (approx):', ((currentStats.totalPoints * 16) / (1024 * 1024)).toFixed(2) + ' MB'],
                ['Color Scheme:', currentStats.colorScheme],
                ['Prime Filter:', document.getElementById('primeFilter').checked ? 'Enabled' : 'Disabled']
            ];
            
            computeStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            yPos += sectionGap;
            
            // Add analysis plots if they exist
            if (hasRadialPlot) {
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.font = 'bold 18px Arial';
                exportCtx.fillText('RADIAL DENSITY PLOT', vizSize + 20, yPos);
                yPos += 30;
                
                const radialCanvas = document.getElementById('radialCanvas');
                exportCtx.drawImage(radialCanvas, vizSize + 20, yPos, 760, 280);
                yPos += 300;
            }
            
            if (hasAngularPlot) {
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.font = 'bold 18px Arial';
                exportCtx.fillText('ANGULAR DISTRIBUTION', vizSize + 20, yPos);
                yPos += 30;
                
                const angularCanvas = document.getElementById('angularCanvas');
                exportCtx.drawImage(angularCanvas, vizSize + 20, yPos, 760, 280);
                yPos += 300;
            }
            
            // Export
            const link = document.createElement('a');
            link.download = `coprime_lattice_${currentStats.N}x${currentStats.N}_${Date.now()}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        };
        
        document.getElementById('exportSVG').onclick = () => {
            const N = parseInt(gridSizeSlider.value);
            const colorSchemeName = colorSchemeSelect.value;
            const colorFunc = colorSchemes[colorSchemeName];
            
            let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${N}" height="${N}" viewBox="0 0 ${N} ${N}">
<rect width="${N}" height="${N}" fill="#000000"/>
`;
            
            latticeData.forEach(point => {
                const color = colorFunc(point.coprime, point.gcd);
                svg += `<rect x="${point.a}" y="${N - point.b - 1}" width="1" height="1" fill="${color}"/>\n`;
            });
            
            svg += '</svg>';
            
            const blob = new Blob([svg], {type: 'image/svg+xml'});
            const link = document.createElement('a');
            link.download = `coprime_lattice_${N}x${N}_${Date.now()}.svg`;
            link.href = URL.createObjectURL(blob);
            link.click();
            
            showStatus('‚úì SVG exported with full grid', 2000);
        };
        
        document.getElementById('exportCSV').onclick = () => {
            // Comprehensive CSV with all mathematical properties
            let csv = 'a,b,gcd,coprime,radius,theta_degrees,theta_radians,real_part,imaginary_part,norm_squared,';
            csv += 'farey_numerator,farey_denominator,farey_decimal,';
            csv += 'mod2_a,mod2_b,mod3_a,mod3_b,mod5_a,mod5_b,';
            csv += 'is_prime_a,is_prime_b,mobius_gcd\n';
            
            latticeData.forEach(point => {
                const {a, b, gcd: gcdVal, coprime} = point;
                
                // Polar coordinates
                const r = polarRadius(a, b);
                const thetaDeg = angleDegrees(a, b);
                const thetaRad = thetaDeg * (Math.PI / 180);
                
                // Complex number properties (treating as Gaussian integer a + bi)
                const realPart = a;
                const imagPart = b;
                const normSquared = a * a + b * b;
                
                // Farey fraction (reduced form)
                const farey = simplifyFraction(a, b);
                const fareyDecimal = b === 0 ? 'Infinity' : (a / b).toFixed(10);
                
                // Modular properties
                const mod2_a = a % 2;
                const mod2_b = b % 2;
                const mod3_a = a % 3;
                const mod3_b = b % 3;
                const mod5_a = a % 5;
                const mod5_b = b % 5;
                
                // Prime properties
                const isPrimeA = isPrime(a);
                const isPrimeB = isPrime(b);
                
                // M√∂bius function of GCD
                const mobiusGcd = mobius(gcdVal);
                
                csv += `${a},${b},${gcdVal},${coprime ? 1 : 0},${r.toFixed(10)},${thetaDeg.toFixed(10)},${thetaRad.toFixed(10)},`;
                csv += `${realPart},${imagPart},${normSquared},`;
                csv += `${farey.num},${farey.den},${fareyDecimal},`;
                csv += `${mod2_a},${mod2_b},${mod3_a},${mod3_b},${mod5_a},${mod5_b},`;
                csv += `${isPrimeA ? 1 : 0},${isPrimeB ? 1 : 0},${mobiusGcd}\n`;
            });
            
            const blob = new Blob([csv], {type: 'text/csv'});
            const link = document.createElement('a');
            link.download = `coprime_lattice_comprehensive_${currentStats.N}x${currentStats.N}_${Date.now()}.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
            
            showStatus('‚úì Comprehensive CSV exported with all properties', 2000);
        };
        
        document.getElementById('exportStats').onclick = () => {
            // Enhanced JSON with comprehensive point data
            const enhancedStats = {
                ...currentStats,
                metadata: {
                    generated_at: new Date().toISOString(),
                    grid_size: currentStats.N,
                    total_points: currentStats.totalPoints,
                    prime_filter_enabled: document.getElementById('primeFilter').checked,
                    color_scheme: currentStats.colorScheme
                },
                comprehensive_point_data: latticeData.map(point => {
                    const {a, b, gcd: gcdVal, coprime} = point;
                    const r = polarRadius(a, b);
                    const thetaDeg = angleDegrees(a, b);
                    const thetaRad = thetaDeg * (Math.PI / 180);
                    const farey = simplifyFraction(a, b);
                    
                    return {
                        cartesian: {a, b},
                        gcd: gcdVal,
                        coprime: coprime,
                        polar: {
                            radius: r,
                            theta_degrees: thetaDeg,
                            theta_radians: thetaRad
                        },
                        gaussian_integer: {
                            real: a,
                            imaginary: b,
                            norm_squared: a * a + b * b
                        },
                        farey_fraction: {
                            numerator: farey.num,
                            denominator: farey.den,
                            decimal: b === 0 ? null : a / b
                        },
                        modular_properties: {
                            mod2: {a: a % 2, b: b % 2},
                            mod3: {a: a % 3, b: b % 3},
                            mod5: {a: a % 5, b: b % 5}
                        },
                        prime_properties: {
                            a_is_prime: isPrime(a),
                            b_is_prime: isPrime(b)
                        },
                        mobius_of_gcd: mobius(gcdVal)
                    };
                })
            };
            
            const json = JSON.stringify(enhancedStats, null, 2);
            const blob = new Blob([json], {type: 'application/json'});
            const link = document.createElement('a');
            link.download = `coprime_lattice_comprehensive_${currentStats.N}x${currentStats.N}_${Date.now()}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
            
            showStatus('‚úì Comprehensive JSON exported with full point data', 2000);
        };
        
        document.getElementById('copyStats').onclick = () => {
            const statsText = `
Coprime Lattice Analysis - ${currentStats.N}√ó${currentStats.N}

GLOBAL STATISTICS:
- Total Points: ${currentStats.totalPoints.toLocaleString()}
- Coprime Points: ${currentStats.coprimeCount.toLocaleString()}
- Coprime Density: ${currentStats.coprimeDensity.toFixed(6)}
- Theoretical (6/œÄ¬≤): 0.607927
- Relative Error: ${currentStats.relativeError}%

DISC ANALYSIS (R=${currentStats.R.toFixed(2)}):
- Points in Disc: ${currentStats.discTotal.toLocaleString()}
- Coprime in Disc V(R): ${currentStats.discCoprime.toLocaleString()}
- Expected (6/œÄ¬≤)œÄR¬≤: ${currentStats.discExpected.toFixed(2)}
- Error E(R): ${currentStats.discError.toFixed(2)}
- |E(R)|/R^(1/2): ${currentStats.errorRatio.toFixed(4)}

M√ñBIUS FUNCTION:
- M(N) = Œ£Œº(n): ${currentStats.mobiusSum}
- |M(N)|/N^(1/2): ${(Math.abs(currentStats.mobiusSum) / Math.sqrt(currentStats.N)).toFixed(4)}
- Œ£Œº(n)/n¬≤: ${currentStats.mobiusOverN2.toFixed(6)}

SAMPLE POINT DATA (first 5 coprime points):
${latticeData.filter(p => p.coprime).slice(0, 5).map(p => {
    const r = polarRadius(p.a, p.b);
    const theta = angleDegrees(p.a, p.b);
    const farey = simplifyFraction(p.a, p.b);
    return `  (${p.a}, ${p.b}): r=${r.toFixed(4)}, Œ∏=${theta.toFixed(2)}¬∞, Farey=${farey.num}/${farey.den}, norm¬≤=${p.a*p.a + p.b*p.b}`;
}).join('\n')}

NOTE: Full comprehensive data available in CSV/JSON exports
            `.trim();
            
            navigator.clipboard.writeText(statsText).then(() => {
                showStatus('‚úì Statistics copied to clipboard!', 2000);
            }).catch(() => {
                alert('Statistics copied to clipboard!');
            });
        };
        
        document.getElementById('exportHTML').onclick = () => {
            // Create a standalone HTML file with the current visualization
            const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coprime Lattice - ${currentStats.N}√ó${currentStats.N}</title>
    <style>
        body { margin: 0; padding: 20px; background: #0a0a0a; color: #e0e0e0; font-family: Arial, sans-serif; }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 { color: #4fc3f7; text-align: center; }
        img { max-width: 100%; border: 1px solid #444; border-radius: 8px; }
        .stats { background: #1a1a1a; padding: 20px; border-radius: 8px; margin-top: 20px; }
        .stat-row { display: flex; justify-content: space-between; padding: 8px 0; border-bottom: 1px solid #2a2a2a; }
        .stat-label { color: #b0b0b0; }
        .stat-value { color: #4fc3f7; font-weight: bold; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Coprime Lattice Visualization</h1>
        <p style="text-align: center; color: #90caf9;">Grid Size: ${currentStats.N}√ó${currentStats.N} | Generated: ${new Date().toLocaleString()}</p>
        <img src="${canvas.toDataURL()}" alt="Coprime Lattice">
        <div class="stats">
            <h2 style="color: #4fc3f7;">Statistics</h2>
            <div class="stat-row"><span class="stat-label">Total Points:</span><span class="stat-value">${currentStats.totalPoints.toLocaleString()}</span></div>
            <div class="stat-row"><span class="stat-label">Coprime Points:</span><span class="stat-value">${currentStats.coprimeCount.toLocaleString()}</span></div>
            <div class="stat-row"><span class="stat-label">Coprime Density:</span><span class="stat-value">${currentStats.coprimeDensity.toFixed(6)}</span></div>
            <div class="stat-row"><span class="stat-label">Theoretical (6/œÄ¬≤):</span><span class="stat-value">0.607927</span></div>
            <div class="stat-row"><span class="stat-label">Relative Error:</span><span class="stat-value">${currentStats.relativeError}%</span></div>
        </div>
    </div>
</body>
</html>`;
            
            const blob = new Blob([htmlContent], {type: 'text/html'});
            const link = document.createElement('a');
            link.download = `coprime_lattice_${currentStats.N}x${currentStats.N}_${Date.now()}.html`;
            link.href = URL.createObjectURL(blob);
            link.click();
        };
        
        document.getElementById('batchExport').onclick = async () => {
            const radiiInput = document.getElementById('batchRadii').value;
            if (!radiiInput.trim()) {
                alert('Please enter comma-separated radii values (e.g., 20,40,60,80)');
                return;
            }
            
            // Validate radii
            const radii = radiiInput.split(',')
                .map(r => parseFloat(r.trim()))
                .filter(r => !isNaN(r) && r > 0 && r <= 100);
            
            if (radii.length === 0) {
                alert('No valid radii values found. Enter values between 0-100.');
                return;
            }
            
            if (radii.some(r => r < 10 || r > 100)) {
                alert('All radii must be between 10 and 100');
                return;
            }
            
            if (!confirm(`Export ${radii.length} visualizations with radii: ${radii.join(', ')}?`)) {
                return;
            }
            
            const originalRadius = circleRadiusSlider.value;
            const originalShowCircle = showCircleCheck.checked;
            const btn = document.getElementById('batchExport');
            const originalText = btn.textContent;
            
            showCircleCheck.checked = true;
            
            for (let i = 0; i < radii.length; i++) {
                const r = radii[i];
                btn.textContent = `Exporting ${i + 1}/${radii.length}...`;
                
                circleRadiusSlider.value = r;
                circleRadiusValue.textContent = r + '%';
                
                await generateVisualization();
                
                // Small delay to ensure rendering completes
                await new Promise(resolve => setTimeout(resolve, 100));
                
                // Export PNG
                const link = document.createElement('a');
                link.download = `coprime_lattice_R${r}_${currentStats.N}x${currentStats.N}_${Date.now()}.png`;
                link.href = canvas.toDataURL('image/png');
                link.click();
                
                // Small delay between exports
                await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            // Restore original settings
            circleRadiusSlider.value = originalRadius;
            showCircleCheck.checked = originalShowCircle;
            circleRadiusValue.textContent = originalRadius + '%';
            btn.textContent = originalText;
            
            await generateVisualization();
            
            alert(`Batch export complete! ${radii.length} images exported.`);
            showStatus(`‚úì Batch export complete: ${radii.length} images`, 3000);
        };
        
        // Export individual chart
        window.exportChart = (canvasId, name) => {
            const chartCanvas = document.getElementById(canvasId);
            const link = document.createElement('a');
            link.download = `${name}_${currentStats.N}x${currentStats.N}_${Date.now()}.png`;
            link.href = chartCanvas.toDataURL('image/png');
            link.click();
        };
        
        // Preset management
        const presets = {
            'prime-focus': {
                primeFilter: true,
                showDiagonals: true,
                showAxes: true,
                showGrid: false,
                colorScheme: 'classic',
                showRadialDensity: true,
                showAngularDist: false
            },
            'rh-analysis': {
                showCircle: true,
                circleRadius: 40,
                analyzeDisc: true,
                showRadialDensity: true,
                showAngularDist: true,
                showDensity: true,
                angularSectors: 12,
                showAxes: true
            },
            'farey-explorer': {
                showFarey: true,
                fareyOrder: 10,
                showDiagonals: true,
                showAxes: true,
                colorScheme: 'monochrome',
                showGrid: true
            },
            'modular-patterns': {
                highlightModular: true,
                modulus: 3,
                residueA: 0,
                residueB: 0,
                showGrid: true,
                colorScheme: 'rainbow'
            },
            'high-res': {
                gridSize: 1000,
                resolution: 7680,
                pointSize: 2,
                showAxes: true,
                colorScheme: 'classic'
            },
            'minimal': {
                showAxes: false,
                showGrid: false,
                showCircle: false,
                showRadialDensity: false,
                showAngularDist: false,
                colorScheme: 'monochrome'
            }
        };
        
        document.getElementById('applyPreset').onclick = () => {
            const presetName = document.getElementById('presetSelect').value;
            if (!presetName) {
                alert('Please select a preset');
                return;
            }
            
            const preset = presets[presetName] || userPresets[presetName];
            if (!preset) {
                alert('Preset not found');
                return;
            }
            
            // Apply preset settings
            if (preset.gridSize !== undefined) {
                gridSizeSlider.value = preset.gridSize;
                gridSizeInput.value = preset.gridSize;
                gridSizeValue.textContent = preset.gridSize;
            }
            if (preset.resolution !== undefined) resolutionSelect.value = preset.resolution;
            if (preset.pointSize !== undefined) {
                pointSizeSlider.value = preset.pointSize;
                pointSizeValue.textContent = preset.pointSize;
            }
            if (preset.colorScheme !== undefined) colorSchemeSelect.value = preset.colorScheme;
            
            if (preset.showAxes !== undefined) document.getElementById('showAxes').checked = preset.showAxes;
            if (preset.showGrid !== undefined) document.getElementById('showGrid').checked = preset.showGrid;
            if (preset.showCircle !== undefined) {
                showCircleCheck.checked = preset.showCircle;
                circleRadiusSlider.disabled = !preset.showCircle;
            }
            if (preset.circleRadius !== undefined) {
                circleRadiusSlider.value = preset.circleRadius;
                circleRadiusValue.textContent = preset.circleRadius + '%';
            }
            
            if (preset.showDiagonals !== undefined) document.getElementById('showDiagonals').checked = preset.showDiagonals;
            if (preset.showFarey !== undefined) {
                document.getElementById('showFarey').checked = preset.showFarey;
                document.getElementById('fareyOrder').disabled = !preset.showFarey;
            }
            if (preset.fareyOrder !== undefined) document.getElementById('fareyOrder').value = preset.fareyOrder;
            
            if (preset.highlightModular !== undefined) {
                document.getElementById('highlightModular').checked = preset.highlightModular;
                const enabled = preset.highlightModular;
                document.getElementById('modulus').disabled = !enabled;
                document.getElementById('residueA').disabled = !enabled;
                document.getElementById('residueB').disabled = !enabled;
            }
            if (preset.modulus !== undefined) document.getElementById('modulus').value = preset.modulus;
            if (preset.residueA !== undefined) document.getElementById('residueA').value = preset.residueA;
            if (preset.residueB !== undefined) document.getElementById('residueB').value = preset.residueB;
            
            if (preset.primeFilter !== undefined) document.getElementById('primeFilter').checked = preset.primeFilter;
            if (preset.analyzeDisc !== undefined) document.getElementById('analyzeDisc').checked = preset.analyzeDisc;
            if (preset.showDensity !== undefined) document.getElementById('showDensity').checked = preset.showDensity;
            
            if (preset.showRadialDensity !== undefined) {
                document.getElementById('showRadialDensity').checked = preset.showRadialDensity;
                document.getElementById('radialDensityCard').style.display = preset.showRadialDensity ? 'block' : 'none';
            }
            if (preset.showAngularDist !== undefined) {
                document.getElementById('showAngularDist').checked = preset.showAngularDist;
                document.getElementById('angularSectors').disabled = !preset.showAngularDist;
                document.getElementById('angularDistCard').style.display = preset.showAngularDist ? 'block' : 'none';
            }
            if (preset.angularSectors !== undefined) document.getElementById('angularSectors').value = preset.angularSectors;
            
            // Regenerate visualization
            setTimeout(() => generateVisualization(), 100);
        };
        
        document.getElementById('savePreset').onclick = () => {
            const name = prompt('Enter a name for this preset:');
            if (!name) return;
            
            // Capture current settings
            const currentPreset = {
                gridSize: parseInt(gridSizeSlider.value),
                resolution: parseInt(resolutionSelect.value),
                pointSize: parseInt(pointSizeSlider.value),
                colorScheme: colorSchemeSelect.value,
                showAxes: document.getElementById('showAxes').checked,
                showGrid: document.getElementById('showGrid').checked,
                showCircle: showCircleCheck.checked,
                circleRadius: parseInt(circleRadiusSlider.value),
                showDiagonals: document.getElementById('showDiagonals').checked,
                showFarey: document.getElementById('showFarey').checked,
                fareyOrder: parseInt(document.getElementById('fareyOrder').value),
                highlightModular: document.getElementById('highlightModular').checked,
                modulus: parseInt(document.getElementById('modulus').value),
                residueA: parseInt(document.getElementById('residueA').value),
                residueB: parseInt(document.getElementById('residueB').value),
                primeFilter: document.getElementById('primeFilter').checked,
                analyzeDisc: document.getElementById('analyzeDisc').checked,
                showDensity: document.getElementById('showDensity').checked,
                showRadialDensity: document.getElementById('showRadialDensity').checked,
                showAngularDist: document.getElementById('showAngularDist').checked,
                angularSectors: parseInt(document.getElementById('angularSectors').value)
            };
            
            userPresets[name] = currentPreset;
            
            // Save to localStorage
            try {
                localStorage.setItem('coprimePresets', JSON.stringify(userPresets));
                
                // Add to dropdown
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name + ' (Custom)';
                document.getElementById('presetSelect').appendChild(option);
                
                alert(`Preset "${name}" saved successfully!`);
                showStatus(`‚úì Preset "${name}" saved`, 2000);
            } catch (e) {
                alert('Could not save preset. Storage may be full.');
            }
        };
        
        // Initial generation
        window.onload = () => {
            // Load user presets into dropdown
            Object.keys(userPresets).forEach(name => {
                const option = document.createElement('option');
                option.value = name;
                option.textContent = name + ' (Custom)';
                document.getElementById('presetSelect').appendChild(option);
            });
            
            setTimeout(generateVisualization, 500);
        };
    </script>
</body>
            </html>
