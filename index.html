
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coprime Lattice & Riemann Hypothesis Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #4fc3f7;
            font-size: 28px;
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 20px;
            color: #90caf9;
            font-size: 14px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .controls-panel {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            height: fit-content;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #b0b0b0;
        }
        
        input[type="number"], input[type="range"], select {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        input[type="number"] {
            margin-bottom: 5px;
        }
        
        input[type="range"] {
            padding: 0;
        }
        
        .range-value {
            text-align: right;
            color: #4fc3f7;
            font-size: 11px;
            margin-top: -8px;
            margin-bottom: 10px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: #2196f3;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: background 0.3s;
            margin-bottom: 8px;
        }
        
        button:hover {
            background: #1976d2;
        }
        
        button.secondary {
            background: #455a64;
        }
        
        button.secondary:hover {
            background: #37474f;
        }
        
        .canvas-container {
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            border: 1px solid #444;
            border-radius: 4px;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .stat-card h3 {
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .point-inspector {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border: 2px solid #4fc3f7;
            margin-bottom: 15px;
        }
        
        .point-inspector.empty {
            border-color: #444;
            opacity: 0.5;
        }
        
        .point-highlight {
            position: absolute;
            pointer-events: none;
            border: 3px solid #ffff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #2a2a2a;
            font-size: 12px;
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #b0b0b0;
        }
        
        .stat-value {
            color: #4fc3f7;
            font-weight: 600;
        }
        
        .export-section {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }
        
        .checkbox-group label {
            margin-bottom: 0;
        }
        
        .loading {
            text-align: center;
            color: #4fc3f7;
            padding: 20px;
            display: none;
        }
        
        .formula-box {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #4fc3f7;
            margin-bottom: 15px;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .formula-box strong {
            color: #4fc3f7;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #2a2a2a;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
        }
        
        .progress-fill {
            height: 100%;
            background: #4fc3f7;
            width: 0%;
            transition: width 0.3s;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            border-bottom: 2px solid #333;
        }
        
        .tab {
            padding: 12px 24px;
            background: #1a1a1a;
            border: 1px solid #333;
            border-bottom: none;
            border-radius: 8px 8px 0 0;
            color: #b0b0b0;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
        }
        
        .tab:hover {
            background: #2a2a2a;
            color: #4fc3f7;
        }
        
        .tab.active {
            background: #2a2a2a;
            color: #4fc3f7;
            border-bottom: 2px solid #4fc3f7;
            margin-bottom: -2px;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .intro-section {
            margin-bottom: 30px;
        }
        
        .intro-section h2 {
            color: #4fc3f7;
            font-size: 20px;
            margin-bottom: 15px;
            border-bottom: 2px solid #333;
            padding-bottom: 8px;
        }
        
        .intro-section h3 {
            color: #90caf9;
            font-size: 16px;
            margin: 20px 0 10px 0;
        }
        
        .intro-section p {
            color: #e0e0e0;
            line-height: 1.8;
            margin-bottom: 12px;
        }
        
        .intro-section ul {
            margin-left: 20px;
            margin-bottom: 15px;
        }
        
        .intro-section li {
            color: #e0e0e0;
            line-height: 1.8;
            margin-bottom: 8px;
        }
        
        .math-formula {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #4fc3f7;
            margin: 15px 0;
            font-family: 'Courier New', monospace;
            color: #90caf9;
            font-size: 14px;
        }
        
        .highlight-box {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #4fc3f7;
            margin: 15px 0;
        }
        
        .highlight-box strong {
            color: #4fc3f7;
        }
        
        .example-box {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #555;
            margin: 15px 0;
        }
        
        .feature-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        
        .feature-card {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border: 1px solid #444;
        }
        
        .feature-card h4 {
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 8px;
        }
        
        .feature-card p {
            font-size: 12px;
            color: #b0b0b0;
            margin: 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Coprime Lattice & Riemann Hypothesis Explorer</h1>
        <div class="subtitle">Interactive visualization of primitive lattice vectors, gcd(a,b)=1 patterns, and their deep connection to Œ∂(s) zeros</div>
        
        <div class="tabs">
            <div class="tab" data-tab="intro">Introduction</div>
            <div class="tab active" data-tab="explorer">Explorer</div>
        </div>
        
        <div id="introTab" class="tab-content">
            <div class="intro-section">
                <h2>Welcome to the Coprime Lattice Explorer</h2>
                <p>
                    This tool provides an interactive visualization of one of the most beautiful connections in mathematics: 
                    the relationship between <strong>coprime integer pairs</strong> (primitive lattice vectors) and the 
                    <strong>Riemann Hypothesis</strong>, one of the most important unsolved problems in mathematics.
                </p>
                
                <div class="highlight-box">
                    <strong>Main Theorem:</strong> The probability that two random integers are coprime converges to 
                    <strong>6/œÄ¬≤ ‚âà 0.6079</strong>, which equals <strong>1/Œ∂(2)</strong>.
                </div>
                
                <p>
                    This explorer focuses on <strong>primitive lattice vectors</strong> - points (a,b) where gcd(a,b) = 1, 
                    also known as "visible points" from the origin. These points form the building blocks of the integer 
                    lattice and have profound connections to Gaussian integers, Fermat's Two-Square Theorem, and the 
                    distribution of prime numbers.
                </p>
            </div>
            
            <div class="intro-section">
                <h2>What Are Coprime Numbers?</h2>
                <p>
                    Two integers <em>a</em> and <em>b</em> are <strong>coprime</strong> (or relatively prime) if their 
                    greatest common divisor (GCD) is 1. In other words, they share no common factors except 1. These 
                    pairs form <strong>primitive lattice vectors</strong> that are "visible" from the origin when you 
                    imagine standing at (0,0) and looking through the lattice.
                </p>
                
                <div class="example-box">
                    <strong>Examples:</strong>
                    <ul>
                        <li>gcd(8, 15) = 1 ‚Üí Coprime ‚úì (Primitive vector)</li>
                        <li>gcd(12, 18) = 6 ‚Üí Not coprime ‚úó (Blocked by (2,3))</li>
                        <li>gcd(7, 11) = 1 ‚Üí Coprime ‚úì (Primitive vector)</li>
                    </ul>
                </div>
                
                <h3>Gaussian Integers & Norm</h3>
                <p>
                    Each lattice point (a,b) corresponds to a <strong>Gaussian integer</strong> z = a + bi. 
                    The norm is N(z) = a¬≤ + b¬≤, which measures the squared distance from the origin. 
                    <strong>Fermat's Two-Square Theorem</strong> states that a prime p can be written as a sum of 
                    two squares (p = a¬≤ + b¬≤) if and only if p ‚â° 1 (mod 4) or p = 2.
                </p>
                
                <p>
                    A fundamental result in number theory states that the probability that two randomly chosen integers 
                    are coprime is <strong>6/œÄ¬≤</strong> ‚âà 0.607927. This remarkable constant connects the geometry of 
                    circles (œÄ) with the distribution of prime numbers!
                </p>
                
                <div class="math-formula">
                    P(gcd(a,b) = 1) = 6/œÄ¬≤ = 1/Œ∂(2) = Œ£ 1/n¬≤ = 1 - 1/4 - 1/9 - 1/25 + ...
                </div>
            </div>
            
            <div class="intro-section">
                <h2>The Riemann Zeta Function</h2>
                <p>
                    The <strong>Riemann zeta function</strong> Œ∂(s) is defined for complex numbers s with Re(s) > 1 as:
                </p>
                
                <div class="math-formula">
                    Œ∂(s) = Œ£(n=1 to ‚àû) 1/n^s = 1/1^s + 1/2^s + 1/3^s + 1/4^s + ...
                </div>
                
                <p>
                    This function has a deep connection to prime numbers through the Euler product formula:
                </p>
                
                <div class="math-formula">
                    Œ∂(s) = ‚àè(p prime) 1/(1 - p^(-s))
                </div>
                
                <p>
                    The reciprocal of Œ∂(s) can be expressed using the <strong>M√∂bius function</strong> Œº(n):
                </p>
                
                <div class="math-formula">
                    1/Œ∂(s) = Œ£(n=1 to ‚àû) Œº(n)/n^s
                </div>
                
                <p>
                    where Œº(n) = 1 if n is a product of an even number of distinct primes, 
                    -1 if n is a product of an odd number of distinct primes, and 0 if n has a squared prime factor.
                </p>
            </div>
            
            <div class="intro-section">
                <h2>The Riemann Hypothesis</h2>
                <p>
                    The <strong>Riemann Hypothesis</strong> (RH) is one of the seven Millennium Prize Problems, 
                    with a $1 million prize for its proof. It states:
                </p>
                
                <div class="highlight-box">
                    <strong>Riemann Hypothesis:</strong> All non-trivial zeros of the Riemann zeta function Œ∂(s) 
                    lie on the critical line Re(s) = 1/2 in the complex plane.
                </div>
                
                <p>
                    In other words, if Œ∂(s) = 0 and s is not a negative even integer, then s = 1/2 + it for some real number t.
                </p>
            </div>
            
            <div class="intro-section">
                <h2>Connection to Coprime Lattice Points</h2>
                <p>
                    Let <strong>V(R)</strong> be the number of coprime lattice points (a, b) inside a disc of radius R 
                    centered at the origin. The Gauss Circle Problem and related theory tell us:
                </p>
                
                <div class="math-formula">
                    V(R) = (6/œÄ¬≤) ¬∑ œÄR¬≤ + E(R)
                </div>
                
                <p>
                    where E(R) is the error term. The <strong>exponent in the error bound</strong> is directly related 
                    to the zeros of Œ∂(s):
                </p>
                
                <div class="highlight-box">
                    <strong>Key Connection:</strong> The Riemann Hypothesis is equivalent to the statement that 
                    <strong>|E(R)| = O(R^(1/2 + Œµ))</strong> for any Œµ > 0.
                    <br><br>
                    The exponent <strong>1/2</strong> here is exactly <strong>Re(s) = 1/2</strong> from the critical line!
                </div>
                
                <p>
                    This means that how coprime lattice points distribute in a circular region is fundamentally 
                    connected to where the zeros of Œ∂(s) lie in the complex plane.
                </p>
            </div>
            
            <div class="intro-section">
                <h2>Tool Features</h2>
                
                <div class="feature-grid">
                    <div class="feature-card">
                        <h4>Grid Parameters</h4>
                        <p>Generate lattice grids from 1√ó1 up to 10,000√ó10,000 points with customizable resolution and point size.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Color Schemes</h4>
                        <p>Multiple visualization modes including classic, heatmap, rainbow by GCD, and more to highlight different patterns.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Disc Analysis</h4>
                        <p>Compute V(R), the error term E(R), and verify the relationship to RH by analyzing circular regions.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>M√∂bius Statistics</h4>
                        <p>Calculate M√∂bius function sums and verify convergence to 1/Œ∂(2) = 6/œÄ¬≤.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Zoom & Pan</h4>
                        <p>Zoom up to 20x and pan around to explore specific regions in detail.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Point Labels</h4>
                        <p>Label points by GCD, fraction, coordinates, or reduced fraction with customizable appearance.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Point Inspector</h4>
                        <p>Click any point to see its properties: GCD, polar coordinates, modular properties, and more.</p>
                    </div>
                    
                    <div class="feature-card">
                        <h4>Export Options</h4>
                        <p>Export visualizations as PNG (with statistics), SVG, CSV data, or JSON statistics.</p>
                    </div>
                </div>
            </div>
            
            <div class="intro-section">
                <h2>How to Use This Tool</h2>
                
                <h3>1. Basic Exploration</h3>
                <ul>
                    <li>Click the "Explorer" tab above to access the interactive tool</li>
                    <li>Start with a moderate grid size (500√ó500) and click "Generate Visualization"</li>
                    <li>Green/white points are coprime pairs; other colors indicate non-coprime pairs</li>
                    <li>Observe the density and distribution patterns</li>
                </ul>
                
                <h3>2. Analyzing the Riemann Hypothesis Connection</h3>
                <ul>
                    <li>Enable "Show Radius Circle" in the Visualization section</li>
                    <li>Adjust the circle radius R to different values</li>
                    <li>Check the "Disc Analysis" statistics to see V(R), E(R), and |E(R)|/R^(1/2)</li>
                    <li>The ratio |E(R)|/R^(1/2) should remain bounded if RH is true</li>
                </ul>
                
                <h3>3. Detailed Point Inspection</h3>
                <ul>
                    <li>Click on any point in the visualization</li>
                    <li>The "Point Inspector" panel shows: coordinates, GCD, polar form, modular properties</li>
                    <li>Compare coprime vs non-coprime points to understand the patterns</li>
                </ul>
                
                <h3>4. Zooming and Labeling</h3>
                <ul>
                    <li>Use the Zoom slider to magnify regions (up to 20x)</li>
                    <li>Pan using the X and Y offset sliders</li>
                    <li>Enable "Show Point Labels" and choose a label type</li>
                    <li>Adjust font size and threshold for optimal visibility</li>
                </ul>
                
                <h3>5. Statistical Analysis</h3>
                <ul>
                    <li>Check "Global Statistics" for overall coprime density (should approach 6/œÄ¬≤ ‚âà 0.6079)</li>
                    <li>Review "M√∂bius Function Analysis" to see Œ£Œº(n)/n¬≤ converging to 6/œÄ¬≤</li>
                    <li>Export statistics as JSON for further analysis</li>
                </ul>
            </div>
            
            <div class="intro-section">
                <h2>Mathematical Background</h2>
                
                <h3>Why 6/œÄ¬≤?</h3>
                <p>
                    The probability that gcd(a,b) = 1 equals 6/œÄ¬≤ because:
                </p>
                <div class="math-formula">
                    P(gcd(a,b) = 1) = ‚àè(p prime) P(p does not divide both a and b)
                    = ‚àè(p prime) (1 - 1/p¬≤)
                    = 1/Œ∂(2) = 1/(œÄ¬≤/6) = 6/œÄ¬≤
                </div>
                
                <h3>Key Mathematical Results</h3>
                <div class="example-box">
                    <strong>Coprime Density:</strong> lim P(gcd(a,b)=1) = 6/œÄ¬≤ = 1/Œ∂(2)<br>
                    <strong>Average Totient:</strong> lim (1/N)Œ£œÜ(m)/m = 6/œÄ¬≤<br>
                    <strong>Farey Growth:</strong> |F_n| ~ (3/œÄ¬≤)n¬≤<br>
                    <strong>Primitive Vectors:</strong> Count in disc of radius R ~ (6/œÄ)R¬≤<br>
                    <strong>Euler Product:</strong> Œ∂(s) = ‚àè(1 - p^(-s))^(-1) over all primes p<br>
                    <strong>M√∂bius Function:</strong> ùüô_gcd=1 = Œ£ Œº(d) over divisors d<br>
                    <strong>RH Connection:</strong> Error term E(R) = O(R^(1/2+Œµ)) ‚ü∫ Riemann Hypothesis
                </div>
                
                <h3>The Error Term and RH</h3>
                <p>
                    If we count coprime points in a disc, the main term is (6/œÄ¬≤)œÄR¬≤ = 6R¬≤/œÄ. 
                    The error E(R) measures the deviation from this expectation. 
                    Better bounds on E(R) are equivalent to information about Œ∂(s) zeros:
                </p>
                <ul>
                    <li><strong>E(R) = O(R)</strong> is easy to prove (trivial bound)</li>
                    <li><strong>E(R) = O(R^(2/3))</strong> can be proven unconditionally</li>
                    <li><strong>E(R) = O(R^(1/2 + Œµ))</strong> is equivalent to RH</li>
                    <li><strong>E(R) = O(R^(1/2))</strong> would be the best possible bound</li>
                </ul>
                
                <h3>M√∂bius Function and Prime Numbers</h3>
                <p>
                    The M√∂bius function Œº(n) encodes information about the prime factorization of n:
                </p>
                <ul>
                    <li>Œº(n) = 1 if n is a product of an <strong>even</strong> number of distinct primes</li>
                    <li>Œº(n) = -1 if n is a product of an <strong>odd</strong> number of distinct primes</li>
                    <li>Œº(n) = 0 if n has a squared prime factor</li>
                </ul>
                <p>
                    Its summatory properties are intimately connected to the distribution of primes and 
                    the zeros of Œ∂(s). The sum M(N) = Œ£Œº(n) oscillates around zero, and RH implies 
                    |M(N)| = O(N^(1/2 + Œµ)).
                </p>
                
                <h3>Euler's Totient Function œÜ(m)</h3>
                <p>
                    The <strong>totient function</strong> œÜ(m) counts how many integers from 1 to m are coprime to m. 
                    The ratio œÜ(m)/m represents the "coprime density" for a specific modulus m. Averaging these ratios 
                    over all moduli converges to 6/œÄ¬≤.
                </p>
                <div class="math-formula">
                    lim (n‚Üí‚àû) (1/n) Œ£(m=1 to n) œÜ(m)/m = 6/œÄ¬≤
                </div>
                <p>
                    Note: While primes have œÜ(p)/p = (p-1)/p ‚Üí 1, which is higher than 6/œÄ¬≤ ‚âà 0.608, primes become 
                    increasingly sparse, so composite numbers with lower ratios dominate the average.
                </p>
            </div>
            
            <div class="intro-section">
                <h2>Ready to Explore?</h2>
                <p>
                    Click the <strong>"Explorer"</strong> tab above to begin your journey into the beautiful 
                    world of coprime lattice points and their connection to one of mathematics' deepest mysteries!
                </p>
                
                <div class="highlight-box">
                    <strong>Technical Features:</strong>
                    <ul style="margin: 10px 0 0 0;">
                        <li>Grid sizes from 1√ó1 to 10,000√ó10,000</li>
                        <li>High-resolution canvas rendering (2K/4K/8K export)</li>
                        <li>Real-time statistics with disc analysis</li>
                        <li>Zoom up to 20x with pan controls</li>
                        <li>Point inspector with polar/modular properties</li>
                        <li>Multiple color schemes and labeling options</li>
                        <li>Export to PNG (with legend), SVG, CSV, and JSON</li>
                        <li>Professional academic styling</li>
                        <li>Mobile-compatible interface</li>
                    </ul>
                </div>
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #333; text-align: center; color: #888; font-size: 12px;">
                    <p><strong>Author:</strong> Wessen Getachew (<a href="https://twitter.com/7dview" style="color: #4fc3f7;">@7dview</a>)</p>
                    <p><strong>Theme:</strong> Classical analytic number theory with modern interactive visualization</p>
                    <p style="margin-top: 10px;">Built with HTML5 Canvas ‚Ä¢ Pure JavaScript ‚Ä¢ No external dependencies</p>
                </div>
            </div>
        </div>
        
        <div id="explorerTab" class="tab-content active">
        <div class="main-grid">
            <div class="controls-panel">
                <div class="control-group">
                    <h3>Point Inspector</h3>
                    <div id="pointInspector" class="point-inspector empty">
                        <div style="text-align: center; color: #888; font-size: 12px;">
                            Click on a point to inspect its properties
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Grid Parameters</h3>
                    <label>Grid Size (N √ó N)</label>
                    <input type="number" id="gridSizeInput" min="1" max="10000" value="500" step="1">
                    <input type="range" id="gridSize" min="1" max="10000" value="500" step="1">
                    <div class="range-value" id="gridSizeValue">500</div>
                    
                    <label>Canvas Resolution</label>
                    <select id="resolution">
                        <option value="2048">2K (2048px)</option>
                        <option value="3840" selected>4K (3840px)</option>
                        <option value="7680">8K (7680px)</option>
                    </select>
                    
                    <label>Point Size (pixels)</label>
                    <input type="range" id="pointSize" min="1" max="10" value="3" step="1">
                    <div class="range-value" id="pointSizeValue">3</div>
                </div>
                
                <div class="control-group">
                    <h3>Visualization</h3>
                    <label>Color Scheme</label>
                    <select id="colorScheme">
                        <option value="classic">Classic (Green/Blue)</option>
                        <option value="heatmap">Heatmap</option>
                        <option value="monochrome">Monochrome</option>
                        <option value="rainbow">Rainbow by GCD</option>
                        <option value="neon">Neon</option>
                    </select>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showCircle">
                        <label>Show Radius Circle</label>
                    </div>
                    
                    <label>Circle Radius (R)</label>
                    <input type="range" id="circleRadius" min="10" max="100" value="40" step="5" disabled>
                    <div class="range-value" id="circleRadiusValue">40%</div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showAxes" checked>
                        <label>Show Axes</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGrid">
                        <label>Show Grid Lines</label>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Labels</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="showLabels">
                        <label>Show Point Labels</label>
                    </div>
                    
                    <label>Label Type</label>
                    <select id="labelType" disabled>
                        <option value="gcd">GCD Value</option>
                        <option value="fraction">a/b Fraction</option>
                        <option value="coordinates">Coordinates (a,b)</option>
                        <option value="reduced">Reduced Fraction</option>
                    </select>
                    
                    <label>Label Threshold (max points to label)</label>
                    <input type="range" id="labelThreshold" min="10" max="500" value="100" step="10" disabled>
                    <div class="range-value" id="labelThresholdValue">100</div>
                    
                    <label>Font Size</label>
                    <input type="range" id="labelFontSize" min="8" max="24" value="12" step="1" disabled>
                    <div class="range-value" id="labelFontSizeValue">12px</div>
                </div>
                
                <div class="control-group">
                    <h3>Zoom & Pan</h3>
                    <label>Zoom Level</label>
                    <input type="range" id="zoomLevel" min="1" max="20" value="1" step="0.5">
                    <div class="range-value" id="zoomLevelValue">1.0x</div>
                    
                    <label>Center X (offset)</label>
                    <input type="range" id="panX" min="-100" max="100" value="0" step="1">
                    <div class="range-value" id="panXValue">0%</div>
                    
                    <label>Center Y (offset)</label>
                    <input type="range" id="panY" min="-100" max="100" value="0" step="1">
                    <div class="range-value" id="panYValue">0%</div>
                    
                    <button class="secondary" id="resetZoom">Reset Zoom & Pan</button>
                </div>
                
                <div class="control-group">
                    <h3>Analysis</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="analyzeDisc" checked>
                        <label>Analyze Disc Region</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showDensity" checked>
                        <label>Calculate Density Statistics</label>
                    </div>
                </div>
                
                <button id="generateBtn">Generate Visualization</button>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="loading" id="loading">Computing...</div>
                
                <div class="control-group">
                    <h3>Export</h3>
                    <div class="export-section">
                        <button class="secondary" id="exportPNG">PNG</button>
                        <button class="secondary" id="exportSVG">SVG</button>
                        <button class="secondary" id="exportCSV">CSV</button>
                    </div>
                    <button class="secondary" id="exportStats">Export Statistics (JSON)</button>
                </div>
                
                <div class="formula-box">
                    <strong>Riemann Hypothesis Connection:</strong><br>
                    V(R) = (6/œÄ¬≤)œÄR¬≤ + O(R^(1/2+Œµ))<br><br>
                    The exponent <strong>1/2</strong> in the error term is exactly <strong>Re(s) = 1/2</strong> on the critical line.
                </div>
            </div>
            
            <div class="canvas-container">
                <div style="position: relative; display: inline-block;">
                    <canvas id="canvas"></canvas>
                    <div id="pointHighlight" class="point-highlight"></div>
                </div>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <h3>Global Statistics</h3>
                <div id="globalStats">
                    <div class="stat-row">
                        <span class="stat-label">Total Points:</span>
                        <span class="stat-value" id="totalPoints">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Coprime Points:</span>
                        <span class="stat-value" id="coprimePoints">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Non-Coprime Points:</span>
                        <span class="stat-value" id="nonCoprimePoints">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Coprime Density:</span>
                        <span class="stat-value" id="coprimeDensity">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Theoretical (6/œÄ¬≤):</span>
                        <span class="stat-value">0.607927</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Relative Error:</span>
                        <span class="stat-value" id="relativeError">-</span>
                    </div>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>Disc Analysis (Radius R)</h3>
                <div id="discStats">
                    <div class="stat-row">
                        <span class="stat-label">Radius R:</span>
                        <span class="stat-value" id="discRadius">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Points in Disc:</span>
                        <span class="stat-value" id="discTotal">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Coprime in Disc V(R):</span>
                        <span class="stat-value" id="discCoprime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Expected (6/œÄ¬≤)œÄR¬≤:</span>
                        <span class="stat-value" id="discExpected">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Error E(R):</span>
                        <span class="stat-value" id="discError">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">|E(R)|/R^(1/2):</span>
                        <span class="stat-value" id="errorRatio">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">log‚ÇÅ‚ÇÄ|E(R)|:</span>
                        <span class="stat-value" id="errorLog">-</span>
                    </div>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>M√∂bius Function Analysis</h3>
                <div id="mobiusStats">
                    <div class="stat-row">
                        <span class="stat-label">M(N) = Œ£Œº(n):</span>
                        <span class="stat-value" id="mobiusSum">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">|M(N)|/N^(1/2):</span>
                        <span class="stat-value" id="mobiusRatio">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Œ£Œº(n)/n:</span>
                        <span class="stat-value" id="mobiusNormalized">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Œ£Œº(n)/n¬≤:</span>
                        <span class="stat-value" id="mobiusSquared">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Expected (1/Œ∂(2)):</span>
                        <span class="stat-value">0.607927</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">GCD Values Found:</span>
                        <span class="stat-value" id="gcdCount">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Œº-Function Range:</span>
                        <span class="stat-value" id="mobiusRange">-1 to +1</span>
                    </div>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>Computational Details</h3>
                <div id="computeStats">
                    <div class="stat-row">
                        <span class="stat-label">Grid Dimensions:</span>
                        <span class="stat-value" id="dimensions">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Canvas Size:</span>
                        <span class="stat-value" id="canvasSize">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Point Size:</span>
                        <span class="stat-value" id="pointSizeStat">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Total Pixels:</span>
                        <span class="stat-value" id="totalPixels">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Generation Time:</span>
                        <span class="stat-value" id="genTime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Memory (approx):</span>
                        <span class="stat-value" id="memUsage">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Color Scheme:</span>
                        <span class="stat-value" id="colorSchemeUsed">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Zoom Level:</span>
                        <span class="stat-value" id="zoomStat">1.0x</span>
                    </div>
                </div>
            </div>
        </div>
        
        <div style="margin-top: 30px; padding: 20px; background: #1a1a1a; border-radius: 8px; border: 1px solid #333; text-align: center;">
            <div style="color: #4fc3f7; font-size: 16px; font-weight: bold; margin-bottom: 15px;">About This Tool</div>
            <div style="color: #b0b0b0; font-size: 12px; line-height: 1.8;">
                <p style="margin-bottom: 10px;">
                    <strong style="color: #90caf9;">Coprime Lattice & Riemann Hypothesis Explorer</strong> visualizes primitive lattice vectors 
                    and their deep connections to the Riemann zeta function, Gaussian integers, and the distribution of primes.
                </p>
                <p style="margin-bottom: 10px;">
                    Built using HTML5 Canvas with pure JavaScript. Implements efficient GCD computation via Euclidean algorithm, 
                    M√∂bius function evaluation, and real-time statistical analysis of coprime density convergence to 6/œÄ¬≤ ‚âà 0.607927.
                </p>
                <p style="margin-bottom: 15px;">
                    <strong style="color: #90caf9;">Key Features:</strong> Zoom & pan, point inspection with polar/modular properties, 
                    disc analysis for RH error bounds, multiple export formats (PNG with legend, SVG, CSV, JSON), 
                    customizable labeling and color schemes.
                </p>
                <div style="padding-top: 15px; border-top: 1px solid #333;">
                    <strong style="color: #4fc3f7;">Author:</strong> Wessen Getachew 
                    (<a href="https://twitter.com/7dview" target="_blank" style="color: #4fc3f7; text-decoration: none;">@7dview</a>) | 
                    <strong style="color: #4fc3f7;">Theme:</strong> Classical analytic number theory with modern interactive visualization
                </div>
            </div>
        </div>
        </div>
    </div>

    <script>
        // Tab switching
        document.querySelectorAll('.tab').forEach(tab => {
            tab.addEventListener('click', () => {
                const targetTab = tab.getAttribute('data-tab');
                
                // Update active tab
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                tab.classList.add('active');
                
                // Update active content
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                if (targetTab === 'intro') {
                    document.getElementById('introTab').classList.add('active');
                } else if (targetTab === 'explorer') {
                    document.getElementById('explorerTab').classList.add('active');
                }
            });
        });
        
        // GCD function using Euclidean algorithm
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b !== 0) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }
        
        // Simplify fraction
        function simplifyFraction(a, b) {
            if (b === 0) return {num: a, den: 1};
            const g = gcd(a, b);
            return {num: a / g, den: b / g};
        }
        
        // Calculate angle in degrees
        function angleDegrees(a, b) {
            if (a === 0 && b === 0) return 0;
            const rad = Math.atan2(b, a);
            const deg = rad * (180 / Math.PI);
            return deg < 0 ? deg + 360 : deg;
        }
        
        // Calculate polar radius
        function polarRadius(a, b) {
            return Math.sqrt(a * a + b * b);
        }
        
        // M√∂bius function
        function mobius(n) {
            if (n === 1) return 1;
            
            let factors = [];
            let temp = n;
            
            for (let i = 2; i * i <= temp; i++) {
                if (temp % i === 0) {
                    let count = 0;
                    while (temp % i === 0) {
                        temp /= i;
                        count++;
                    }
                    if (count > 1) return 0; // squared factor
                    factors.push(i);
                }
            }
            
            if (temp > 1) factors.push(temp);
            
            return factors.length % 2 === 0 ? 1 : -1;
        }
        
        // Color schemes
        const colorSchemes = {
            classic: (isCoprime, gcdVal) => isCoprime ? '#70ff70' : '#4060b0',
            heatmap: (isCoprime, gcdVal) => {
                if (isCoprime) return '#ffff00';
                const intensity = Math.min(gcdVal / 10, 1);
                const r = Math.floor(255 * intensity);
                const b = Math.floor(255 * (1 - intensity));
                return `rgb(${r},0,${b})`;
            },
            monochrome: (isCoprime, gcdVal) => isCoprime ? '#ffffff' : '#202020',
            rainbow: (isCoprime, gcdVal) => {
                if (isCoprime) return '#ffffff';
                const hue = (gcdVal * 30) % 360;
                return `hsl(${hue}, 70%, 50%)`;
            },
            neon: (isCoprime, gcdVal) => isCoprime ? '#00ffff' : '#ff00ff'
        };
        
        // Global state
        let latticeData = null;
        let currentStats = null;
        let latticeGrid = null; // For fast lookup by coordinates
        let currentN = 0;
        let currentPixelsPerUnit = 0;
        let baseCanvas = null; // Store the base visualization without zoom/labels
        
        // UI Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const gridSizeSlider = document.getElementById('gridSize');
        const gridSizeInput = document.getElementById('gridSizeInput');
        const gridSizeValue = document.getElementById('gridSizeValue');
        const pointSizeSlider = document.getElementById('pointSize');
        const pointSizeValue = document.getElementById('pointSizeValue');
        const circleRadiusSlider = document.getElementById('circleRadius');
        const circleRadiusValue = document.getElementById('circleRadiusValue');
        const showCircleCheck = document.getElementById('showCircle');
        const resolutionSelect = document.getElementById('resolution');
        const colorSchemeSelect = document.getElementById('colorScheme');
        
        // Label controls
        const showLabelsCheck = document.getElementById('showLabels');
        const labelTypeSelect = document.getElementById('labelType');
        const labelThresholdSlider = document.getElementById('labelThreshold');
        const labelThresholdValue = document.getElementById('labelThresholdValue');
        const labelFontSizeSlider = document.getElementById('labelFontSize');
        const labelFontSizeValue = document.getElementById('labelFontSizeValue');
        
        // Zoom controls
        const zoomLevelSlider = document.getElementById('zoomLevel');
        const zoomLevelValue = document.getElementById('zoomLevelValue');
        const panXSlider = document.getElementById('panX');
        const panXValue = document.getElementById('panXValue');
        const panYSlider = document.getElementById('panY');
        const panYValue = document.getElementById('panYValue');
        
        // Sync input and slider
        gridSizeSlider.oninput = () => {
            gridSizeValue.textContent = gridSizeSlider.value;
            gridSizeInput.value = gridSizeSlider.value;
        };
        gridSizeInput.oninput = () => {
            const val = Math.max(1, Math.min(10000, parseInt(gridSizeInput.value) || 1));
            gridSizeInput.value = val;
            gridSizeSlider.value = val;
            gridSizeValue.textContent = val;
        };
        pointSizeSlider.oninput = () => pointSizeValue.textContent = pointSizeSlider.value;
        circleRadiusSlider.oninput = () => circleRadiusValue.textContent = circleRadiusSlider.value + '%';
        
        labelThresholdSlider.oninput = () => {
            labelThresholdValue.textContent = labelThresholdSlider.value;
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        labelFontSizeSlider.oninput = () => {
            labelFontSizeValue.textContent = labelFontSizeSlider.value + 'px';
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        zoomLevelSlider.oninput = () => {
            zoomLevelValue.textContent = parseFloat(zoomLevelSlider.value).toFixed(1) + 'x';
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        panXSlider.oninput = () => {
            panXValue.textContent = panXSlider.value + '%';
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        panYSlider.oninput = () => {
            panYValue.textContent = panYSlider.value + '%';
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        showCircleCheck.onchange = () => {
            circleRadiusSlider.disabled = !showCircleCheck.checked;
        };
        
        showLabelsCheck.onchange = () => {
            const enabled = showLabelsCheck.checked;
            labelTypeSelect.disabled = !enabled;
            labelThresholdSlider.disabled = !enabled;
            labelFontSizeSlider.disabled = !enabled;
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        labelTypeSelect.onchange = () => {
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        document.getElementById('resetZoom').onclick = () => {
            zoomLevelSlider.value = 1;
            panXSlider.value = 0;
            panYSlider.value = 0;
            zoomLevelValue.textContent = '1.0x';
            panXValue.textContent = '0%';
            panYValue.textContent = '0%';
            if (baseCanvas) redrawWithZoomAndLabels();
        };
        
        // Generate visualization
        document.getElementById('generateBtn').onclick = generateVisualization;
        
        async function generateVisualization() {
            const startTime = performance.now();
            const loading = document.getElementById('loading');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            
            loading.style.display = 'block';
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
            
            // Get parameters
            const N = parseInt(gridSizeSlider.value);
            const resolution = parseInt(resolutionSelect.value);
            const pointSize = parseInt(pointSizeSlider.value);
            const colorSchemeName = colorSchemeSelect.value;
            const colorFunc = colorSchemes[colorSchemeName];
            const showCircle = showCircleCheck.checked;
            const circleRadiusPct = parseInt(circleRadiusSlider.value) / 100;
            const showAxes = document.getElementById('showAxes').checked;
            const showGrid = document.getElementById('showGrid').checked;
            const analyzeDisc = document.getElementById('analyzeDisc').checked;
            
            // Setup canvas
            canvas.width = resolution;
            canvas.height = resolution;
            
            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, resolution, resolution);
            
            // Calculate scaling
            const pixelsPerUnit = resolution / N;
            currentN = N;
            currentPixelsPerUnit = pixelsPerUnit;
            
            // Data structures
            latticeData = [];
            latticeGrid = {}; // For fast coordinate lookup
            let coprimeCount = 0;
            let gcdDistribution = {};
            let mobiusSum = 0;
            let mobiusOverN = 0;
            let mobiusOverN2 = 0;
            
            const R = N * circleRadiusPct / 2;
            let discTotal = 0;
            let discCoprime = 0;
            const centerX = N / 2;
            const centerY = N / 2;
            
            // Generate and draw points
            for (let a = 0; a < N; a++) {
                for (let b = 0; b < N; b++) {
                    const gcdVal = gcd(a, b);
                    const isCoprime = gcdVal === 1;
                    
                    const pointData = {a, b, gcd: gcdVal, coprime: isCoprime};
                    latticeData.push(pointData);
                    
                    // Store in grid for fast lookup
                    latticeGrid[`${a},${b}`] = pointData;
                    
                    if (isCoprime) coprimeCount++;
                    
                    gcdDistribution[gcdVal] = (gcdDistribution[gcdVal] || 0) + 1;
                    
                    // Draw point
                    const x = a * pixelsPerUnit;
                    const y = (N - b - 1) * pixelsPerUnit;
                    
                    ctx.fillStyle = colorFunc(isCoprime, gcdVal);
                    ctx.fillRect(x, y, pointSize, pointSize);
                    
                    // Disc analysis
                    if (analyzeDisc && showCircle) {
                        const dx = a - centerX;
                        const dy = b - centerY;
                        const distSq = dx * dx + dy * dy;
                        
                        if (distSq <= R * R) {
                            discTotal++;
                            if (isCoprime) discCoprime++;
                        }
                    }
                }
                
                // Update progress
                const progress = ((a + 1) / N) * 100;
                progressFill.style.width = progress + '%';
                
                if (a % 50 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // Calculate M√∂bius statistics
            for (let n = 1; n <= N; n++) {
                const mu = mobius(n);
                mobiusSum += mu;
                mobiusOverN += mu / n;
                mobiusOverN2 += mu / (n * n);
            }
            
            // Draw overlays
            if (showGrid) {
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 0.5;
                const gridStep = Math.max(1, Math.floor(N / 20));
                for (let i = 0; i <= N; i += gridStep) {
                    ctx.beginPath();
                    ctx.moveTo(i * pixelsPerUnit, 0);
                    ctx.lineTo(i * pixelsPerUnit, resolution);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, i * pixelsPerUnit);
                    ctx.lineTo(resolution, i * pixelsPerUnit);
                    ctx.stroke();
                }
            }
            
            if (showCircle) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(
                    centerX * pixelsPerUnit,
                    (N - centerY) * pixelsPerUnit,
                    R * pixelsPerUnit,
                    0,
                    2 * Math.PI
                );
                ctx.stroke();
            }
            
            if (showAxes) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                
                // X axis
                ctx.beginPath();
                ctx.moveTo(0, (N / 2) * pixelsPerUnit);
                ctx.lineTo(resolution, (N / 2) * pixelsPerUnit);
                ctx.stroke();
                
                // Y axis
                ctx.beginPath();
                ctx.moveTo((N / 2) * pixelsPerUnit, 0);
                ctx.lineTo((N / 2) * pixelsPerUnit, resolution);
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#ffffff';
                ctx.font = `${Math.max(12, resolution / 200)}px Arial`;
                ctx.fillText('a', resolution - 30, (N / 2) * pixelsPerUnit - 10);
                ctx.fillText('b', (N / 2) * pixelsPerUnit + 10, 30);
            }
            
            const endTime = performance.now();
            const genTime = ((endTime - startTime) / 1000).toFixed(2);
            
            // Calculate statistics
            const totalPoints = N * N;
            const coprimeDensity = coprimeCount / totalPoints;
            const theoretical = 6 / (Math.PI * Math.PI);
            const relativeError = ((coprimeDensity - theoretical) / theoretical * 100).toFixed(3);
            
            const discExpected = theoretical * Math.PI * R * R;
            const discError = discCoprime - discExpected;
            const errorRatio = Math.abs(discError) / Math.sqrt(R);
            
            currentStats = {
                N,
                totalPoints,
                coprimeCount,
                coprimeDensity,
                theoretical,
                relativeError,
                R,
                discTotal,
                discCoprime,
                discExpected,
                discError,
                errorRatio,
                mobiusSum,
                mobiusOverN,
                mobiusOverN2,
                gcdDistribution,
                genTime,
                resolution,
                pointSize,
                colorScheme: colorSchemeName
            };
            
            updateStatistics();
            
            loading.style.display = 'none';
            progressBar.style.display = 'none';
            
            // Save base canvas for zoom/label operations
            baseCanvas = document.createElement('canvas');
            baseCanvas.width = canvas.width;
            baseCanvas.height = canvas.height;
            baseCanvas.getContext('2d').drawImage(canvas, 0, 0);
        }
        
        function redrawWithZoomAndLabels() {
            if (!baseCanvas) return;
            
            const zoom = parseFloat(zoomLevelSlider.value);
            const panXPct = parseFloat(panXSlider.value) / 100;
            const panYPct = parseFloat(panYSlider.value) / 100;
            
            // Clear and setup canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Apply zoom and pan transformations
            ctx.save();
            
            // Translate to center, apply zoom, then pan
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.scale(zoom, zoom);
            ctx.translate(-canvas.width / 2 - (panXPct * canvas.width), -canvas.height / 2 - (panYPct * canvas.height));
            
            // Draw the base visualization
            ctx.drawImage(baseCanvas, 0, 0);
            
            ctx.restore();
            
            // Add labels if enabled
            if (showLabelsCheck.checked) {
                addLabels(zoom, panXPct, panYPct);
            }
        }
        
        function addLabels(zoom, panXPct, panYPct) {
            const labelType = labelTypeSelect.value;
            const threshold = parseInt(labelThresholdSlider.value);
            const fontSize = parseInt(labelFontSizeSlider.value);
            
            if (!latticeData || latticeData.length === 0) return;
            
            // Determine which points are visible and should be labeled
            const centerX = currentN / 2;
            const centerY = currentN / 2;
            
            // Calculate visible region based on zoom and pan
            const visibleWidth = currentN / zoom;
            const visibleHeight = currentN / zoom;
            const viewCenterX = centerX + panXPct * currentN;
            const viewCenterY = centerY + panYPct * currentN;
            
            const minA = Math.max(0, Math.floor(viewCenterX - visibleWidth / 2));
            const maxA = Math.min(currentN - 1, Math.ceil(viewCenterX + visibleWidth / 2));
            const minB = Math.max(0, Math.floor(viewCenterY - visibleHeight / 2));
            const maxB = Math.min(currentN - 1, Math.ceil(viewCenterY + visibleHeight / 2));
            
            // Filter points in visible region
            let visiblePoints = [];
            for (let a = minA; a <= maxA; a++) {
                for (let b = minB; b <= maxB; b++) {
                    const key = `${a},${b}`;
                    if (latticeGrid[key]) {
                        visiblePoints.push(latticeGrid[key]);
                    }
                }
            }
            
            // Limit to threshold
            if (visiblePoints.length > threshold) {
                // Sample evenly or prioritize coprime points
                const step = Math.ceil(visiblePoints.length / threshold);
                visiblePoints = visiblePoints.filter((_, idx) => idx % step === 0);
            }
            
            // Draw labels
            ctx.save();
            ctx.font = `${fontSize}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            visiblePoints.forEach(point => {
                const {a, b, gcd: gcdVal} = point;
                
                let labelText = '';
                switch (labelType) {
                    case 'gcd':
                        labelText = gcdVal.toString();
                        break;
                    case 'fraction':
                        labelText = b === 0 ? '‚àû' : `${a}/${b}`;
                        break;
                    case 'coordinates':
                        labelText = `${a},${b}`;
                        break;
                    case 'reduced':
                        const frac = simplifyFraction(a, b);
                        labelText = `${frac.num}/${frac.den}`;
                        break;
                }
                
                // Calculate screen position with zoom and pan
                const x = a * currentPixelsPerUnit;
                const y = (currentN - b - 1) * currentPixelsPerUnit;
                
                // Apply transformations
                const screenX = (x - canvas.width / 2 - (panXPct * canvas.width)) * zoom + canvas.width / 2;
                const screenY = (y - canvas.height / 2 - (panYPct * canvas.height)) * zoom + canvas.height / 2;
                
                // Draw label with background
                const metrics = ctx.measureText(labelText);
                const padding = 3;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(
                    screenX - metrics.width / 2 - padding,
                    screenY - fontSize / 2 - padding,
                    metrics.width + padding * 2,
                    fontSize + padding * 2
                );
                
                ctx.fillStyle = point.coprime ? '#70ff70' : '#4fc3f7';
                ctx.fillText(labelText, screenX, screenY);
            });
            
            ctx.restore();
        }
        
        // Point inspection on click
        canvas.addEventListener('click', (event) => {
            if (!latticeGrid || currentN === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const canvasX = (event.clientX - rect.left) * scaleX;
            const canvasY = (event.clientY - rect.top) * scaleY;
            
            // Account for zoom and pan
            const zoom = parseFloat(zoomLevelSlider.value);
            const panXPct = parseFloat(panXSlider.value) / 100;
            const panYPct = parseFloat(panYSlider.value) / 100;
            
            // Reverse transformation
            const unzoomedX = (canvasX - canvas.width / 2) / zoom + canvas.width / 2 + (panXPct * canvas.width);
            const unzoomedY = (canvasY - canvas.height / 2) / zoom + canvas.height / 2 + (panYPct * canvas.height);
            
            // Convert to lattice coordinates
            const a = Math.floor(unzoomedX / currentPixelsPerUnit);
            const b = currentN - Math.floor(unzoomedY / currentPixelsPerUnit) - 1;
            
            // Check bounds
            if (a < 0 || a >= currentN || b < 0 || b >= currentN) {
                return;
            }
            
            // Get point data
            const key = `${a},${b}`;
            const point = latticeGrid[key];
            
            if (point) {
                displayPointInfo(point);
                highlightPoint(a, b);
            }
        });
        
        function displayPointInfo(point) {
            const {a, b, gcd: gcdVal, coprime} = point;
            
            // Calculate properties
            const frac = simplifyFraction(a, b);
            const r = polarRadius(a, b);
            const theta = angleDegrees(a, b);
            const thetaRad = theta * (Math.PI / 180);
            
            // Modular properties
            const mod2_a = a % 2;
            const mod2_b = b % 2;
            const mod3_a = a % 3;
            const mod3_b = b % 3;
            const mod5_a = a % 5;
            const mod5_b = b % 5;
            
            const inspector = document.getElementById('pointInspector');
            inspector.className = 'point-inspector';
            
            inspector.innerHTML = `
                <div style="margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px solid #444;">
                    <div style="font-size: 16px; font-weight: bold; color: #4fc3f7;">Point (${a}, ${b})</div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
                    <div>
                        <div style="color: #888;">Cartesian (a, b)</div>
                        <div style="color: #4fc3f7; font-weight: bold;">(${a}, ${b})</div>
                    </div>
                    <div>
                        <div style="color: #888;">GCD(a, b)</div>
                        <div style="color: ${coprime ? '#70ff70' : '#ff7070'}; font-weight: bold;">${gcdVal} ${coprime ? '‚òÖ' : ''}</div>
                    </div>
                    
                    <div>
                        <div style="color: #888;">Coprime</div>
                        <div style="color: ${coprime ? '#70ff70' : '#ff7070'}; font-weight: bold;">${coprime ? 'Yes' : 'No'}</div>
                    </div>
                    <div>
                        <div style="color: #888;">Simplified Ratio</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${frac.num}/${frac.den}</div>
                    </div>
                    
                    <div>
                        <div style="color: #888;">Radius r</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${r.toFixed(4)}</div>
                    </div>
                    <div>
                        <div style="color: #888;">Angle Œ∏</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${theta.toFixed(2)}¬∞</div>
                    </div>
                    
                    <div>
                        <div style="color: #888;">Œ∏ (radians)</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${thetaRad.toFixed(4)}</div>
                    </div>
                    <div>
                        <div style="color: #888;">Polar (r, Œ∏)</div>
                        <div style="color: #4fc3f7; font-weight: bold;">(${r.toFixed(2)}, ${theta.toFixed(1)}¬∞)</div>
                    </div>
                </div>
                
                <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #444;">
                    <div style="color: #888; font-size: 11px; margin-bottom: 6px;">Modular Properties</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; font-size: 11px;">
                        <div>
                            <div style="color: #888;">mod 2</div>
                            <div style="color: #90caf9;">(${mod2_a}, ${mod2_b})</div>
                        </div>
                        <div>
                            <div style="color: #888;">mod 3</div>
                            <div style="color: #90caf9;">(${mod3_a}, ${mod3_b})</div>
                        </div>
                        <div>
                            <div style="color: #888;">mod 5</div>
                            <div style="color: #90caf9;">(${mod5_a}, ${mod5_b})</div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #444;">
                    <div style="color: #888; font-size: 11px; margin-bottom: 6px;">Additional Info</div>
                    <div style="font-size: 11px; line-height: 1.6;">
                        <div style="color: #b0b0b0;">a¬≤ + b¬≤ = <span style="color: #4fc3f7;">${a*a + b*b}</span></div>
                        <div style="color: #b0b0b0;">Distance from origin: <span style="color: #4fc3f7;">${r.toFixed(4)}</span></div>
                        ${gcdVal > 1 ? `<div style="color: #b0b0b0;">Reduced point: <span style="color: #4fc3f7;">(${frac.num}, ${frac.den})</span></div>` : ''}
                    </div>
                </div>
            `;
        }
        
        function highlightPoint(a, b) {
            const highlight = document.getElementById('pointHighlight');
            const rect = canvas.getBoundingClientRect();
            
            const zoom = parseFloat(zoomLevelSlider.value);
            const panXPct = parseFloat(panXSlider.value) / 100;
            const panYPct = parseFloat(panYSlider.value) / 100;
            
            const x = a * currentPixelsPerUnit;
            const y = (currentN - b - 1) * currentPixelsPerUnit;
            
            // Apply zoom and pan to highlight position
            const screenX = (x - canvas.width / 2 - (panXPct * canvas.width)) * zoom + canvas.width / 2;
            const screenY = (y - canvas.height / 2 - (panYPct * canvas.height)) * zoom + canvas.height / 2;
            
            // Scale to display size
            const displayScale = rect.width / canvas.width;
            const displayX = screenX * displayScale;
            const displayY = screenY * displayScale;
            
            highlight.style.left = displayX + 'px';
            highlight.style.top = displayY + 'px';
            highlight.style.width = Math.max(20, currentPixelsPerUnit * displayScale * zoom * 2) + 'px';
            highlight.style.height = Math.max(20, currentPixelsPerUnit * displayScale * zoom * 2) + 'px';
            highlight.style.display = 'block';
            
            // Fade out after 2 seconds
            setTimeout(() => {
                highlight.style.display = 'none';
            }, 2000);
        }
        
        function updateStatistics() {
            if (!currentStats) return;
            
            const s = currentStats;
            
            // Global stats
            document.getElementById('totalPoints').textContent = s.totalPoints.toLocaleString();
            document.getElementById('coprimePoints').textContent = s.coprimeCount.toLocaleString();
            document.getElementById('nonCoprimePoints').textContent = (s.totalPoints - s.coprimeCount).toLocaleString();
            document.getElementById('coprimeDensity').textContent = s.coprimeDensity.toFixed(6);
            document.getElementById('relativeError').textContent = s.relativeError + '%';
            
            // Disc stats
            if (document.getElementById('analyzeDisc').checked && document.getElementById('showCircle').checked) {
                document.getElementById('discRadius').textContent = s.R.toFixed(2);
                document.getElementById('discTotal').textContent = s.discTotal.toLocaleString();
                document.getElementById('discCoprime').textContent = s.discCoprime.toLocaleString();
                document.getElementById('discExpected').textContent = s.discExpected.toFixed(2);
                document.getElementById('discError').textContent = s.discError.toFixed(2);
                document.getElementById('errorRatio').textContent = s.errorRatio.toFixed(4);
                document.getElementById('errorLog').textContent = Math.log10(Math.abs(s.discError)).toFixed(4);
            } else {
                document.getElementById('discRadius').textContent = 'N/A';
                document.getElementById('discTotal').textContent = 'N/A';
                document.getElementById('discCoprime').textContent = 'N/A';
                document.getElementById('discExpected').textContent = 'N/A';
                document.getElementById('discError').textContent = 'N/A';
                document.getElementById('errorRatio').textContent = 'N/A';
                document.getElementById('errorLog').textContent = 'N/A';
            }
            
            // M√∂bius stats
            document.getElementById('mobiusSum').textContent = s.mobiusSum;
            document.getElementById('mobiusRatio').textContent = (Math.abs(s.mobiusSum) / Math.sqrt(s.N)).toFixed(4);
            document.getElementById('mobiusNormalized').textContent = s.mobiusOverN.toFixed(6);
            document.getElementById('mobiusSquared').textContent = s.mobiusOverN2.toFixed(6);
            document.getElementById('gcdCount').textContent = Object.keys(s.gcdDistribution).length;
            
            // Compute stats
            document.getElementById('dimensions').textContent = `${s.N} √ó ${s.N}`;
            document.getElementById('canvasSize').textContent = `${s.resolution} √ó ${s.resolution}`;
            document.getElementById('pointSizeStat').textContent = s.pointSize + 'px';
            document.getElementById('totalPixels').textContent = (s.resolution * s.resolution).toLocaleString();
            document.getElementById('genTime').textContent = s.genTime + 's';
            document.getElementById('memUsage').textContent = ((s.totalPoints * 16) / (1024 * 1024)).toFixed(2) + ' MB';
            document.getElementById('colorSchemeUsed').textContent = s.colorScheme;
            document.getElementById('zoomStat').textContent = parseFloat(zoomLevelSlider.value).toFixed(1) + 'x';
        }
        
        // Export functions
        document.getElementById('exportPNG').onclick = () => {
            // Create a temporary canvas with stats overlay
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            
            // Set dimensions (visualization + legend area)
            const vizSize = canvas.width;
            const legendWidth = 800;
            exportCanvas.width = vizSize + legendWidth;
            exportCanvas.height = vizSize;
            
            // Draw the visualization
            exportCtx.drawImage(canvas, 0, 0);
            
            // Draw legend background
            exportCtx.fillStyle = '#1a1a1a';
            exportCtx.fillRect(vizSize, 0, legendWidth, vizSize);
            
            // Draw legend content
            exportCtx.fillStyle = '#e0e0e0';
            exportCtx.font = 'bold 24px Arial';
            exportCtx.fillText('Statistics', vizSize + 20, 40);
            
            let yPos = 80;
            const lineHeight = 28;
            const sectionGap = 40;
            exportCtx.font = '16px Arial';
            
            // Global Statistics
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('GLOBAL STATISTICS', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            exportCtx.fillStyle = '#b0b0b0';
            const globalStats = [
                ['Total Points:', currentStats.totalPoints.toLocaleString()],
                ['Coprime Points:', currentStats.coprimeCount.toLocaleString()],
                ['Non-Coprime Points:', (currentStats.totalPoints - currentStats.coprimeCount).toLocaleString()],
                ['Coprime Density:', currentStats.coprimeDensity.toFixed(6)],
                ['Theoretical (6/œÄ¬≤):', '0.607927'],
                ['Relative Error:', currentStats.relativeError + '%']
            ];
            
            globalStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            yPos += sectionGap;
            
            // Disc Analysis
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('DISC ANALYSIS (RADIUS R)', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            const discStats = [
                ['Radius R:', currentStats.R.toFixed(2)],
                ['Points in Disc:', currentStats.discTotal.toLocaleString()],
                ['Coprime in Disc V(R):', currentStats.discCoprime.toLocaleString()],
                ['Expected (6/œÄ¬≤)œÄR¬≤:', currentStats.discExpected.toFixed(2)],
                ['Error E(R):', currentStats.discError.toFixed(2)],
                ['|E(R)|/R^(1/2):', currentStats.errorRatio.toFixed(4)],
                ['log‚ÇÅ‚ÇÄ|E(R)|:', Math.log10(Math.abs(currentStats.discError)).toFixed(4)]
            ];
            
            discStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            yPos += sectionGap;
            
            // M√∂bius Analysis
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('M√ñBIUS FUNCTION', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            const mobiusStats = [
                ['M(N) = Œ£Œº(n):', currentStats.mobiusSum.toString()],
                ['|M(N)|/N^(1/2):', (Math.abs(currentStats.mobiusSum) / Math.sqrt(currentStats.N)).toFixed(4)],
                ['Œ£Œº(n)/n:', currentStats.mobiusOverN.toFixed(6)],
                ['Œ£Œº(n)/n¬≤:', currentStats.mobiusOverN2.toFixed(6)],
                ['Expected (1/Œ∂(2)):', '0.607927'],
                ['GCD Values Found:', Object.keys(currentStats.gcdDistribution).length.toString()]
            ];
            
            mobiusStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            yPos += sectionGap;
            
            // Computational Details
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('COMPUTATIONAL DETAILS', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            const computeStats = [
                ['Grid Dimensions:', `${currentStats.N} √ó ${currentStats.N}`],
                ['Canvas Size:', `${currentStats.resolution} √ó ${currentStats.resolution}`],
                ['Point Size:', currentStats.pointSize + 'px'],
                ['Generation Time:', currentStats.genTime + 's'],
                ['Memory (approx):', ((currentStats.totalPoints * 16) / (1024 * 1024)).toFixed(2) + ' MB'],
                ['Color Scheme:', currentStats.colorScheme]
            ];
            
            computeStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            // Export
            const link = document.createElement('a');
            link.download = `coprime_lattice_${currentStats.N}x${currentStats.N}_${Date.now()}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        };
        
        document.getElementById('exportSVG').onclick = () => {
            const N = parseInt(gridSizeSlider.value);
            const colorSchemeName = colorSchemeSelect.value;
            const colorFunc = colorSchemes[colorSchemeName];
            
            let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${N}" height="${N}" viewBox="0 0 ${N} ${N}">
<rect width="${N}" height="${N}" fill="#000000"/>
`;
            
            latticeData.forEach(point => {
                const color = colorFunc(point.coprime, point.gcd);
                svg += `<rect x="${point.a}" y="${N - point.b - 1}" width="1" height="1" fill="${color}"/>\n`;
            });
            
            svg += '</svg>';
            
            const blob = new Blob([svg], {type: 'image/svg+xml'});
            const link = document.createElement('a');
            link.download = `coprime_lattice_${N}x${N}_${Date.now()}.svg`;
            link.href = URL.createObjectURL(blob);
            link.click();
        };
        
        document.getElementById('exportCSV').onclick = () => {
            let csv = 'a,b,gcd,coprime\n';
            latticeData.forEach(point => {
                csv += `${point.a},${point.b},${point.gcd},${point.coprime ? 1 : 0}\n`;
            });
            
            const blob = new Blob([csv], {type: 'text/csv'});
            const link = document.createElement('a');
            link.download = `coprime_lattice_${currentStats.N}x${currentStats.N}_${Date.now()}.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
        };
        
        document.getElementById('exportStats').onclick = () => {
            const json = JSON.stringify(currentStats, null, 2);
            const blob = new Blob([json], {type: 'application/json'});
            const link = document.createElement('a');
            link.download = `coprime_lattice_stats_${currentStats.N}x${currentStats.N}_${Date.now()}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        };
        
        // Initial generation
        window.onload = () => {
            setTimeout(generateVisualization, 500);
        };
    </script>
</body>
    </html>
