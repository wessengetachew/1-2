
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coprime Lattice & Riemann Hypothesis Explorer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #0a0a0a;
            color: #e0e0e0;
            padding: 20px;
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 10px;
            color: #4fc3f7;
            font-size: 28px;
        }
        
        .subtitle {
            text-align: center;
            margin-bottom: 20px;
            color: #90caf9;
            font-size: 14px;
        }
        
        .main-grid {
            display: grid;
            grid-template-columns: 350px 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }
        
        .controls-panel {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
            height: fit-content;
        }
        
        .control-group {
            margin-bottom: 20px;
        }
        
        .control-group h3 {
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #b0b0b0;
        }
        
        input[type="number"], input[type="range"], select {
            width: 100%;
            padding: 8px;
            background: #2a2a2a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        input[type="number"] {
            margin-bottom: 5px;
        }
        
        input[type="range"] {
            padding: 0;
        }
        
        .range-value {
            text-align: right;
            color: #4fc3f7;
            font-size: 11px;
            margin-top: -8px;
            margin-bottom: 10px;
        }
        
        button {
            width: 100%;
            padding: 10px;
            background: #2196f3;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
            font-size: 13px;
            font-weight: 600;
            transition: background 0.3s;
            margin-bottom: 8px;
        }
        
        button:hover {
            background: #1976d2;
        }
        
        button.secondary {
            background: #455a64;
        }
        
        button.secondary:hover {
            background: #37474f;
        }
        
        .canvas-container {
            background: #1a1a1a;
            border-radius: 8px;
            border: 1px solid #333;
            padding: 20px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        canvas {
            border: 1px solid #444;
            border-radius: 4px;
            max-width: 100%;
            height: auto;
            cursor: crosshair;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        
        .stat-card {
            background: #1a1a1a;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        
        .stat-card h3 {
            color: #4fc3f7;
            font-size: 14px;
            margin-bottom: 15px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .point-inspector {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border: 2px solid #4fc3f7;
            margin-bottom: 15px;
        }
        
        .point-inspector.empty {
            border-color: #444;
            opacity: 0.5;
        }
        
        .point-highlight {
            position: absolute;
            pointer-events: none;
            border: 3px solid #ffff00;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            display: none;
        }
        
        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #2a2a2a;
            font-size: 12px;
        }
        
        .stat-row:last-child {
            border-bottom: none;
        }
        
        .stat-label {
            color: #b0b0b0;
        }
        
        .stat-value {
            color: #4fc3f7;
            font-weight: 600;
        }
        
        .export-section {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }
        
        .checkbox-group {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        
        .checkbox-group input[type="checkbox"] {
            width: auto;
            margin-right: 8px;
        }
        
        .checkbox-group label {
            margin-bottom: 0;
        }
        
        .loading {
            text-align: center;
            color: #4fc3f7;
            padding: 20px;
            display: none;
        }
        
        .formula-box {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid #4fc3f7;
            margin-bottom: 15px;
            font-size: 12px;
            line-height: 1.6;
        }
        
        .formula-box strong {
            color: #4fc3f7;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: #2a2a2a;
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
            display: none;
        }
        
        .progress-fill {
            height: 100%;
            background: #4fc3f7;
            width: 0%;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Coprime Lattice & Riemann Hypothesis Explorer</h1>
        <div class="subtitle">Interactive visualization of gcd(a,b)=1 patterns and their connection to ζ(s) zeros</div>
        
        <div class="main-grid">
            <div class="controls-panel">
                <div class="control-group">
                    <h3>Point Inspector</h3>
                    <div id="pointInspector" class="point-inspector empty">
                        <div style="text-align: center; color: #888; font-size: 12px;">
                            Click on a point to inspect its properties
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Grid Parameters</h3>
                    <label>Grid Size (N × N)</label>
                    <input type="number" id="gridSizeInput" min="1" max="10000" value="500" step="1">
                    <input type="range" id="gridSize" min="1" max="10000" value="500" step="1">
                    <div class="range-value" id="gridSizeValue">500</div>
                    
                    <label>Canvas Resolution</label>
                    <select id="resolution">
                        <option value="2048">2K (2048px)</option>
                        <option value="3840" selected>4K (3840px)</option>
                        <option value="7680">8K (7680px)</option>
                    </select>
                    
                    <label>Point Size (pixels)</label>
                    <input type="range" id="pointSize" min="1" max="10" value="3" step="1">
                    <div class="range-value" id="pointSizeValue">3</div>
                </div>
                
                <div class="control-group">
                    <h3>Visualization</h3>
                    <label>Color Scheme</label>
                    <select id="colorScheme">
                        <option value="classic">Classic (Green/Blue)</option>
                        <option value="heatmap">Heatmap</option>
                        <option value="monochrome">Monochrome</option>
                        <option value="rainbow">Rainbow by GCD</option>
                        <option value="neon">Neon</option>
                    </select>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showCircle">
                        <label>Show Radius Circle</label>
                    </div>
                    
                    <label>Circle Radius (R)</label>
                    <input type="range" id="circleRadius" min="10" max="100" value="40" step="5" disabled>
                    <div class="range-value" id="circleRadiusValue">40%</div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showAxes" checked>
                        <label>Show Axes</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showGrid">
                        <label>Show Grid Lines</label>
                    </div>
                </div>
                
                <div class="control-group">
                    <h3>Analysis</h3>
                    <div class="checkbox-group">
                        <input type="checkbox" id="analyzeDisc" checked>
                        <label>Analyze Disc Region</label>
                    </div>
                    
                    <div class="checkbox-group">
                        <input type="checkbox" id="showDensity" checked>
                        <label>Calculate Density Statistics</label>
                    </div>
                </div>
                
                <button id="generateBtn">Generate Visualization</button>
                <div class="progress-bar" id="progressBar">
                    <div class="progress-fill" id="progressFill"></div>
                </div>
                <div class="loading" id="loading">Computing...</div>
                
                <div class="control-group">
                    <h3>Export</h3>
                    <div class="export-section">
                        <button class="secondary" id="exportPNG">PNG</button>
                        <button class="secondary" id="exportSVG">SVG</button>
                        <button class="secondary" id="exportCSV">CSV</button>
                    </div>
                    <button class="secondary" id="exportStats">Export Statistics (JSON)</button>
                </div>
                
                <div class="formula-box">
                    <strong>Riemann Hypothesis Connection:</strong><br>
                    V(R) = (6/π²)πR² + O(R^(1/2+ε))<br><br>
                    The exponent <strong>1/2</strong> in the error term is exactly <strong>Re(s) = 1/2</strong> on the critical line.
                </div>
            </div>
            
            <div class="canvas-container">
                <div style="position: relative; display: inline-block;">
                    <canvas id="canvas"></canvas>
                    <div id="pointHighlight" class="point-highlight"></div>
                </div>
            </div>
        </div>
        
        <div class="stats-grid">
            <div class="stat-card">
                <h3>Global Statistics</h3>
                <div id="globalStats">
                    <div class="stat-row">
                        <span class="stat-label">Total Points:</span>
                        <span class="stat-value" id="totalPoints">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Coprime Points:</span>
                        <span class="stat-value" id="coprimePoints">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Non-Coprime Points:</span>
                        <span class="stat-value" id="nonCoprimePoints">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Coprime Density:</span>
                        <span class="stat-value" id="coprimeDensity">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Theoretical (6/π²):</span>
                        <span class="stat-value">0.607927</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Relative Error:</span>
                        <span class="stat-value" id="relativeError">-</span>
                    </div>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>Disc Analysis (Radius R)</h3>
                <div id="discStats">
                    <div class="stat-row">
                        <span class="stat-label">Radius R:</span>
                        <span class="stat-value" id="discRadius">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Points in Disc:</span>
                        <span class="stat-value" id="discTotal">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Coprime in Disc V(R):</span>
                        <span class="stat-value" id="discCoprime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Expected (6/π²)πR²:</span>
                        <span class="stat-value" id="discExpected">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Error E(R):</span>
                        <span class="stat-value" id="discError">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">|E(R)|/R^(1/2):</span>
                        <span class="stat-value" id="errorRatio">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">log₁₀|E(R)|:</span>
                        <span class="stat-value" id="errorLog">-</span>
                    </div>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>Möbius Function Analysis</h3>
                <div id="mobiusStats">
                    <div class="stat-row">
                        <span class="stat-label">M(N) = Σμ(n):</span>
                        <span class="stat-value" id="mobiusSum">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">|M(N)|/N^(1/2):</span>
                        <span class="stat-value" id="mobiusRatio">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Σμ(n)/n:</span>
                        <span class="stat-value" id="mobiusNormalized">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Σμ(n)/n²:</span>
                        <span class="stat-value" id="mobiusSquared">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Expected (1/ζ(2)):</span>
                        <span class="stat-value">0.607927</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">GCD Values Found:</span>
                        <span class="stat-value" id="gcdCount">-</span>
                    </div>
                </div>
            </div>
            
            <div class="stat-card">
                <h3>Computational Details</h3>
                <div id="computeStats">
                    <div class="stat-row">
                        <span class="stat-label">Grid Dimensions:</span>
                        <span class="stat-value" id="dimensions">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Canvas Size:</span>
                        <span class="stat-value" id="canvasSize">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Point Size:</span>
                        <span class="stat-value" id="pointSizeStat">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Generation Time:</span>
                        <span class="stat-value" id="genTime">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Memory (approx):</span>
                        <span class="stat-value" id="memUsage">-</span>
                    </div>
                    <div class="stat-row">
                        <span class="stat-label">Color Scheme:</span>
                        <span class="stat-value" id="colorSchemeUsed">-</span>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // GCD function using Euclidean algorithm
        function gcd(a, b) {
            a = Math.abs(a);
            b = Math.abs(b);
            while (b !== 0) {
                let temp = b;
                b = a % b;
                a = temp;
            }
            return a;
        }
        
        // Simplify fraction
        function simplifyFraction(a, b) {
            if (b === 0) return {num: a, den: 1};
            const g = gcd(a, b);
            return {num: a / g, den: b / g};
        }
        
        // Calculate angle in degrees
        function angleDegrees(a, b) {
            if (a === 0 && b === 0) return 0;
            const rad = Math.atan2(b, a);
            const deg = rad * (180 / Math.PI);
            return deg < 0 ? deg + 360 : deg;
        }
        
        // Calculate polar radius
        function polarRadius(a, b) {
            return Math.sqrt(a * a + b * b);
        }
        
        // Möbius function
        function mobius(n) {
            if (n === 1) return 1;
            
            let factors = [];
            let temp = n;
            
            for (let i = 2; i * i <= temp; i++) {
                if (temp % i === 0) {
                    let count = 0;
                    while (temp % i === 0) {
                        temp /= i;
                        count++;
                    }
                    if (count > 1) return 0; // squared factor
                    factors.push(i);
                }
            }
            
            if (temp > 1) factors.push(temp);
            
            return factors.length % 2 === 0 ? 1 : -1;
        }
        
        // Color schemes
        const colorSchemes = {
            classic: (isCoprime, gcdVal) => isCoprime ? '#70ff70' : '#4060b0',
            heatmap: (isCoprime, gcdVal) => {
                if (isCoprime) return '#ffff00';
                const intensity = Math.min(gcdVal / 10, 1);
                const r = Math.floor(255 * intensity);
                const b = Math.floor(255 * (1 - intensity));
                return `rgb(${r},0,${b})`;
            },
            monochrome: (isCoprime, gcdVal) => isCoprime ? '#ffffff' : '#202020',
            rainbow: (isCoprime, gcdVal) => {
                if (isCoprime) return '#ffffff';
                const hue = (gcdVal * 30) % 360;
                return `hsl(${hue}, 70%, 50%)`;
            },
            neon: (isCoprime, gcdVal) => isCoprime ? '#00ffff' : '#ff00ff'
        };
        
        // Global state
        let latticeData = null;
        let currentStats = null;
        let latticeGrid = null; // For fast lookup by coordinates
        let currentN = 0;
        let currentPixelsPerUnit = 0;
        
        // UI Elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        const gridSizeSlider = document.getElementById('gridSize');
        const gridSizeInput = document.getElementById('gridSizeInput');
        const gridSizeValue = document.getElementById('gridSizeValue');
        const pointSizeSlider = document.getElementById('pointSize');
        const pointSizeValue = document.getElementById('pointSizeValue');
        const circleRadiusSlider = document.getElementById('circleRadius');
        const circleRadiusValue = document.getElementById('circleRadiusValue');
        const showCircleCheck = document.getElementById('showCircle');
        const resolutionSelect = document.getElementById('resolution');
        const colorSchemeSelect = document.getElementById('colorScheme');
        
        // Sync input and slider
        gridSizeSlider.oninput = () => {
            gridSizeValue.textContent = gridSizeSlider.value;
            gridSizeInput.value = gridSizeSlider.value;
        };
        gridSizeInput.oninput = () => {
            const val = Math.max(1, Math.min(10000, parseInt(gridSizeInput.value) || 1));
            gridSizeInput.value = val;
            gridSizeSlider.value = val;
            gridSizeValue.textContent = val;
        };
        pointSizeSlider.oninput = () => pointSizeValue.textContent = pointSizeSlider.value;
        circleRadiusSlider.oninput = () => circleRadiusValue.textContent = circleRadiusSlider.value + '%';
        
        showCircleCheck.onchange = () => {
            circleRadiusSlider.disabled = !showCircleCheck.checked;
        };
        
        // Generate visualization
        document.getElementById('generateBtn').onclick = generateVisualization;
        
        async function generateVisualization() {
            const startTime = performance.now();
            const loading = document.getElementById('loading');
            const progressBar = document.getElementById('progressBar');
            const progressFill = document.getElementById('progressFill');
            
            loading.style.display = 'block';
            progressBar.style.display = 'block';
            progressFill.style.width = '0%';
            
            // Get parameters
            const N = parseInt(gridSizeSlider.value);
            const resolution = parseInt(resolutionSelect.value);
            const pointSize = parseInt(pointSizeSlider.value);
            const colorSchemeName = colorSchemeSelect.value;
            const colorFunc = colorSchemes[colorSchemeName];
            const showCircle = showCircleCheck.checked;
            const circleRadiusPct = parseInt(circleRadiusSlider.value) / 100;
            const showAxes = document.getElementById('showAxes').checked;
            const showGrid = document.getElementById('showGrid').checked;
            const analyzeDisc = document.getElementById('analyzeDisc').checked;
            
            // Setup canvas
            canvas.width = resolution;
            canvas.height = resolution;
            
            // Clear canvas
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, resolution, resolution);
            
            // Calculate scaling
            const pixelsPerUnit = resolution / N;
            currentN = N;
            currentPixelsPerUnit = pixelsPerUnit;
            
            // Data structures
            latticeData = [];
            latticeGrid = {}; // For fast coordinate lookup
            let coprimeCount = 0;
            let gcdDistribution = {};
            let mobiusSum = 0;
            let mobiusOverN = 0;
            let mobiusOverN2 = 0;
            
            const R = N * circleRadiusPct / 2;
            let discTotal = 0;
            let discCoprime = 0;
            const centerX = N / 2;
            const centerY = N / 2;
            
            // Generate and draw points
            for (let a = 0; a < N; a++) {
                for (let b = 0; b < N; b++) {
                    const gcdVal = gcd(a, b);
                    const isCoprime = gcdVal === 1;
                    
                    const pointData = {a, b, gcd: gcdVal, coprime: isCoprime};
                    latticeData.push(pointData);
                    
                    // Store in grid for fast lookup
                    latticeGrid[`${a},${b}`] = pointData;
                    
                    if (isCoprime) coprimeCount++;
                    
                    gcdDistribution[gcdVal] = (gcdDistribution[gcdVal] || 0) + 1;
                    
                    // Draw point
                    const x = a * pixelsPerUnit;
                    const y = (N - b - 1) * pixelsPerUnit;
                    
                    ctx.fillStyle = colorFunc(isCoprime, gcdVal);
                    ctx.fillRect(x, y, pointSize, pointSize);
                    
                    // Disc analysis
                    if (analyzeDisc && showCircle) {
                        const dx = a - centerX;
                        const dy = b - centerY;
                        const distSq = dx * dx + dy * dy;
                        
                        if (distSq <= R * R) {
                            discTotal++;
                            if (isCoprime) discCoprime++;
                        }
                    }
                }
                
                // Update progress
                const progress = ((a + 1) / N) * 100;
                progressFill.style.width = progress + '%';
                
                if (a % 50 === 0) {
                    await new Promise(resolve => setTimeout(resolve, 0));
                }
            }
            
            // Calculate Möbius statistics
            for (let n = 1; n <= N; n++) {
                const mu = mobius(n);
                mobiusSum += mu;
                mobiusOverN += mu / n;
                mobiusOverN2 += mu / (n * n);
            }
            
            // Draw overlays
            if (showGrid) {
                ctx.strokeStyle = '#333333';
                ctx.lineWidth = 0.5;
                const gridStep = Math.max(1, Math.floor(N / 20));
                for (let i = 0; i <= N; i += gridStep) {
                    ctx.beginPath();
                    ctx.moveTo(i * pixelsPerUnit, 0);
                    ctx.lineTo(i * pixelsPerUnit, resolution);
                    ctx.stroke();
                    
                    ctx.beginPath();
                    ctx.moveTo(0, i * pixelsPerUnit);
                    ctx.lineTo(resolution, i * pixelsPerUnit);
                    ctx.stroke();
                }
            }
            
            if (showCircle) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.arc(
                    centerX * pixelsPerUnit,
                    (N - centerY) * pixelsPerUnit,
                    R * pixelsPerUnit,
                    0,
                    2 * Math.PI
                );
                ctx.stroke();
            }
            
            if (showAxes) {
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                
                // X axis
                ctx.beginPath();
                ctx.moveTo(0, (N / 2) * pixelsPerUnit);
                ctx.lineTo(resolution, (N / 2) * pixelsPerUnit);
                ctx.stroke();
                
                // Y axis
                ctx.beginPath();
                ctx.moveTo((N / 2) * pixelsPerUnit, 0);
                ctx.lineTo((N / 2) * pixelsPerUnit, resolution);
                ctx.stroke();
                
                // Labels
                ctx.fillStyle = '#ffffff';
                ctx.font = `${Math.max(12, resolution / 200)}px Arial`;
                ctx.fillText('a', resolution - 30, (N / 2) * pixelsPerUnit - 10);
                ctx.fillText('b', (N / 2) * pixelsPerUnit + 10, 30);
            }
            
            const endTime = performance.now();
            const genTime = ((endTime - startTime) / 1000).toFixed(2);
            
            // Calculate statistics
            const totalPoints = N * N;
            const coprimeDensity = coprimeCount / totalPoints;
            const theoretical = 6 / (Math.PI * Math.PI);
            const relativeError = ((coprimeDensity - theoretical) / theoretical * 100).toFixed(3);
            
            const discExpected = theoretical * Math.PI * R * R;
            const discError = discCoprime - discExpected;
            const errorRatio = Math.abs(discError) / Math.sqrt(R);
            
            currentStats = {
                N,
                totalPoints,
                coprimeCount,
                coprimeDensity,
                theoretical,
                relativeError,
                R,
                discTotal,
                discCoprime,
                discExpected,
                discError,
                errorRatio,
                mobiusSum,
                mobiusOverN,
                mobiusOverN2,
                gcdDistribution,
                genTime,
                resolution,
                pointSize,
                colorScheme: colorSchemeName
            };
            
            updateStatistics();
            
            loading.style.display = 'none';
            progressBar.style.display = 'none';
        }
        
        // Point inspection on click
        canvas.addEventListener('click', (event) => {
            if (!latticeGrid || currentN === 0) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const canvasX = (event.clientX - rect.left) * scaleX;
            const canvasY = (event.clientY - rect.top) * scaleY;
            
            // Convert to lattice coordinates
            const a = Math.floor(canvasX / currentPixelsPerUnit);
            const b = currentN - Math.floor(canvasY / currentPixelsPerUnit) - 1;
            
            // Check bounds
            if (a < 0 || a >= currentN || b < 0 || b >= currentN) {
                return;
            }
            
            // Get point data
            const key = `${a},${b}`;
            const point = latticeGrid[key];
            
            if (point) {
                displayPointInfo(point);
                highlightPoint(a, b);
            }
        });
        
        function displayPointInfo(point) {
            const {a, b, gcd: gcdVal, coprime} = point;
            
            // Calculate properties
            const frac = simplifyFraction(a, b);
            const r = polarRadius(a, b);
            const theta = angleDegrees(a, b);
            const thetaRad = theta * (Math.PI / 180);
            
            // Modular properties
            const mod2_a = a % 2;
            const mod2_b = b % 2;
            const mod3_a = a % 3;
            const mod3_b = b % 3;
            const mod5_a = a % 5;
            const mod5_b = b % 5;
            
            const inspector = document.getElementById('pointInspector');
            inspector.className = 'point-inspector';
            
            inspector.innerHTML = `
                <div style="margin-bottom: 12px; padding-bottom: 10px; border-bottom: 1px solid #444;">
                    <div style="font-size: 16px; font-weight: bold; color: #4fc3f7;">Point (${a}, ${b})</div>
                </div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 11px;">
                    <div>
                        <div style="color: #888;">Cartesian (a, b)</div>
                        <div style="color: #4fc3f7; font-weight: bold;">(${a}, ${b})</div>
                    </div>
                    <div>
                        <div style="color: #888;">GCD(a, b)</div>
                        <div style="color: ${coprime ? '#70ff70' : '#ff7070'}; font-weight: bold;">${gcdVal} ${coprime ? '★' : ''}</div>
                    </div>
                    
                    <div>
                        <div style="color: #888;">Coprime</div>
                        <div style="color: ${coprime ? '#70ff70' : '#ff7070'}; font-weight: bold;">${coprime ? 'Yes' : 'No'}</div>
                    </div>
                    <div>
                        <div style="color: #888;">Simplified Ratio</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${frac.num}/${frac.den}</div>
                    </div>
                    
                    <div>
                        <div style="color: #888;">Radius r</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${r.toFixed(4)}</div>
                    </div>
                    <div>
                        <div style="color: #888;">Angle θ</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${theta.toFixed(2)}°</div>
                    </div>
                    
                    <div>
                        <div style="color: #888;">θ (radians)</div>
                        <div style="color: #4fc3f7; font-weight: bold;">${thetaRad.toFixed(4)}</div>
                    </div>
                    <div>
                        <div style="color: #888;">Polar (r, θ)</div>
                        <div style="color: #4fc3f7; font-weight: bold;">(${r.toFixed(2)}, ${theta.toFixed(1)}°)</div>
                    </div>
                </div>
                
                <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #444;">
                    <div style="color: #888; font-size: 11px; margin-bottom: 6px;">Modular Properties</div>
                    <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; font-size: 11px;">
                        <div>
                            <div style="color: #888;">mod 2</div>
                            <div style="color: #90caf9;">(${mod2_a}, ${mod2_b})</div>
                        </div>
                        <div>
                            <div style="color: #888;">mod 3</div>
                            <div style="color: #90caf9;">(${mod3_a}, ${mod3_b})</div>
                        </div>
                        <div>
                            <div style="color: #888;">mod 5</div>
                            <div style="color: #90caf9;">(${mod5_a}, ${mod5_b})</div>
                        </div>
                    </div>
                </div>
                
                <div style="margin-top: 12px; padding-top: 10px; border-top: 1px solid #444;">
                    <div style="color: #888; font-size: 11px; margin-bottom: 6px;">Additional Info</div>
                    <div style="font-size: 11px; line-height: 1.6;">
                        <div style="color: #b0b0b0;">a² + b² = <span style="color: #4fc3f7;">${a*a + b*b}</span></div>
                        <div style="color: #b0b0b0;">Distance from origin: <span style="color: #4fc3f7;">${r.toFixed(4)}</span></div>
                        ${gcdVal > 1 ? `<div style="color: #b0b0b0;">Reduced point: <span style="color: #4fc3f7;">(${frac.num}, ${frac.den})</span></div>` : ''}
                    </div>
                </div>
            `;
        }
        
        function highlightPoint(a, b) {
            const highlight = document.getElementById('pointHighlight');
            const rect = canvas.getBoundingClientRect();
            
            const x = a * currentPixelsPerUnit;
            const y = (currentN - b - 1) * currentPixelsPerUnit;
            
            // Scale to display size
            const displayScale = rect.width / canvas.width;
            const displayX = x * displayScale;
            const displayY = y * displayScale;
            
            highlight.style.left = displayX + 'px';
            highlight.style.top = displayY + 'px';
            highlight.style.width = Math.max(20, currentPixelsPerUnit * displayScale * 2) + 'px';
            highlight.style.height = Math.max(20, currentPixelsPerUnit * displayScale * 2) + 'px';
            highlight.style.display = 'block';
            
            // Fade out after 2 seconds
            setTimeout(() => {
                highlight.style.display = 'none';
            }, 2000);
        }
        
        function updateStatistics() {
            if (!currentStats) return;
            
            const s = currentStats;
            
            // Global stats
            document.getElementById('totalPoints').textContent = s.totalPoints.toLocaleString();
            document.getElementById('coprimePoints').textContent = s.coprimeCount.toLocaleString();
            document.getElementById('nonCoprimePoints').textContent = (s.totalPoints - s.coprimeCount).toLocaleString();
            document.getElementById('coprimeDensity').textContent = s.coprimeDensity.toFixed(6);
            document.getElementById('relativeError').textContent = s.relativeError + '%';
            
            // Disc stats
            if (document.getElementById('analyzeDisc').checked && document.getElementById('showCircle').checked) {
                document.getElementById('discRadius').textContent = s.R.toFixed(2);
                document.getElementById('discTotal').textContent = s.discTotal.toLocaleString();
                document.getElementById('discCoprime').textContent = s.discCoprime.toLocaleString();
                document.getElementById('discExpected').textContent = s.discExpected.toFixed(2);
                document.getElementById('discError').textContent = s.discError.toFixed(2);
                document.getElementById('errorRatio').textContent = s.errorRatio.toFixed(4);
                document.getElementById('errorLog').textContent = Math.log10(Math.abs(s.discError)).toFixed(4);
            } else {
                document.getElementById('discRadius').textContent = 'N/A';
                document.getElementById('discTotal').textContent = 'N/A';
                document.getElementById('discCoprime').textContent = 'N/A';
                document.getElementById('discExpected').textContent = 'N/A';
                document.getElementById('discError').textContent = 'N/A';
                document.getElementById('errorRatio').textContent = 'N/A';
                document.getElementById('errorLog').textContent = 'N/A';
            }
            
            // Möbius stats
            document.getElementById('mobiusSum').textContent = s.mobiusSum;
            document.getElementById('mobiusRatio').textContent = (Math.abs(s.mobiusSum) / Math.sqrt(s.N)).toFixed(4);
            document.getElementById('mobiusNormalized').textContent = s.mobiusOverN.toFixed(6);
            document.getElementById('mobiusSquared').textContent = s.mobiusOverN2.toFixed(6);
            document.getElementById('gcdCount').textContent = Object.keys(s.gcdDistribution).length;
            
            // Compute stats
            document.getElementById('dimensions').textContent = `${s.N} × ${s.N}`;
            document.getElementById('canvasSize').textContent = `${s.resolution} × ${s.resolution}`;
            document.getElementById('pointSizeStat').textContent = s.pointSize + 'px';
            document.getElementById('genTime').textContent = s.genTime + 's';
            document.getElementById('memUsage').textContent = ((s.totalPoints * 16) / (1024 * 1024)).toFixed(2) + ' MB';
            document.getElementById('colorSchemeUsed').textContent = s.colorScheme;
        }
        
        // Export functions
        document.getElementById('exportPNG').onclick = () => {
            // Create a temporary canvas with stats overlay
            const exportCanvas = document.createElement('canvas');
            const exportCtx = exportCanvas.getContext('2d');
            
            // Set dimensions (visualization + legend area)
            const vizSize = canvas.width;
            const legendWidth = 800;
            exportCanvas.width = vizSize + legendWidth;
            exportCanvas.height = vizSize;
            
            // Draw the visualization
            exportCtx.drawImage(canvas, 0, 0);
            
            // Draw legend background
            exportCtx.fillStyle = '#1a1a1a';
            exportCtx.fillRect(vizSize, 0, legendWidth, vizSize);
            
            // Draw legend content
            exportCtx.fillStyle = '#e0e0e0';
            exportCtx.font = 'bold 24px Arial';
            exportCtx.fillText('Statistics', vizSize + 20, 40);
            
            let yPos = 80;
            const lineHeight = 28;
            const sectionGap = 40;
            exportCtx.font = '16px Arial';
            
            // Global Statistics
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('GLOBAL STATISTICS', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            exportCtx.fillStyle = '#b0b0b0';
            const globalStats = [
                ['Total Points:', currentStats.totalPoints.toLocaleString()],
                ['Coprime Points:', currentStats.coprimeCount.toLocaleString()],
                ['Non-Coprime Points:', (currentStats.totalPoints - currentStats.coprimeCount).toLocaleString()],
                ['Coprime Density:', currentStats.coprimeDensity.toFixed(6)],
                ['Theoretical (6/π²):', '0.607927'],
                ['Relative Error:', currentStats.relativeError + '%']
            ];
            
            globalStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            yPos += sectionGap;
            
            // Disc Analysis
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('DISC ANALYSIS (RADIUS R)', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            const discStats = [
                ['Radius R:', currentStats.R.toFixed(2)],
                ['Points in Disc:', currentStats.discTotal.toLocaleString()],
                ['Coprime in Disc V(R):', currentStats.discCoprime.toLocaleString()],
                ['Expected (6/π²)πR²:', currentStats.discExpected.toFixed(2)],
                ['Error E(R):', currentStats.discError.toFixed(2)],
                ['|E(R)|/R^(1/2):', currentStats.errorRatio.toFixed(4)],
                ['log₁₀|E(R)|:', Math.log10(Math.abs(currentStats.discError)).toFixed(4)]
            ];
            
            discStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            yPos += sectionGap;
            
            // Möbius Analysis
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('MÖBIUS FUNCTION', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            const mobiusStats = [
                ['M(N) = Σμ(n):', currentStats.mobiusSum.toString()],
                ['|M(N)|/N^(1/2):', (Math.abs(currentStats.mobiusSum) / Math.sqrt(currentStats.N)).toFixed(4)],
                ['Σμ(n)/n:', currentStats.mobiusOverN.toFixed(6)],
                ['Σμ(n)/n²:', currentStats.mobiusOverN2.toFixed(6)],
                ['Expected (1/ζ(2)):', '0.607927'],
                ['GCD Values Found:', Object.keys(currentStats.gcdDistribution).length.toString()]
            ];
            
            mobiusStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            yPos += sectionGap;
            
            // Computational Details
            exportCtx.fillStyle = '#4fc3f7';
            exportCtx.font = 'bold 18px Arial';
            exportCtx.fillText('COMPUTATIONAL DETAILS', vizSize + 20, yPos);
            yPos += 30;
            
            exportCtx.font = '15px Arial';
            const computeStats = [
                ['Grid Dimensions:', `${currentStats.N} × ${currentStats.N}`],
                ['Canvas Size:', `${currentStats.resolution} × ${currentStats.resolution}`],
                ['Point Size:', currentStats.pointSize + 'px'],
                ['Generation Time:', currentStats.genTime + 's'],
                ['Memory (approx):', ((currentStats.totalPoints * 16) / (1024 * 1024)).toFixed(2) + ' MB'],
                ['Color Scheme:', currentStats.colorScheme]
            ];
            
            computeStats.forEach(([label, value]) => {
                exportCtx.fillStyle = '#b0b0b0';
                exportCtx.fillText(label, vizSize + 20, yPos);
                exportCtx.fillStyle = '#4fc3f7';
                exportCtx.fillText(value, vizSize + 400, yPos);
                yPos += lineHeight;
            });
            
            // Export
            const link = document.createElement('a');
            link.download = `coprime_lattice_${currentStats.N}x${currentStats.N}_${Date.now()}.png`;
            link.href = exportCanvas.toDataURL('image/png');
            link.click();
        };
        
        document.getElementById('exportSVG').onclick = () => {
            const N = parseInt(gridSizeSlider.value);
            const colorSchemeName = colorSchemeSelect.value;
            const colorFunc = colorSchemes[colorSchemeName];
            
            let svg = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" width="${N}" height="${N}" viewBox="0 0 ${N} ${N}">
<rect width="${N}" height="${N}" fill="#000000"/>
`;
            
            latticeData.forEach(point => {
                const color = colorFunc(point.coprime, point.gcd);
                svg += `<rect x="${point.a}" y="${N - point.b - 1}" width="1" height="1" fill="${color}"/>\n`;
            });
            
            svg += '</svg>';
            
            const blob = new Blob([svg], {type: 'image/svg+xml'});
            const link = document.createElement('a');
            link.download = `coprime_lattice_${N}x${N}_${Date.now()}.svg`;
            link.href = URL.createObjectURL(blob);
            link.click();
        };
        
        document.getElementById('exportCSV').onclick = () => {
            let csv = 'a,b,gcd,coprime\n';
            latticeData.forEach(point => {
                csv += `${point.a},${point.b},${point.gcd},${point.coprime ? 1 : 0}\n`;
            });
            
            const blob = new Blob([csv], {type: 'text/csv'});
            const link = document.createElement('a');
            link.download = `coprime_lattice_${currentStats.N}x${currentStats.N}_${Date.now()}.csv`;
            link.href = URL.createObjectURL(blob);
            link.click();
        };
        
        document.getElementById('exportStats').onclick = () => {
            const json = JSON.stringify(currentStats, null, 2);
            const blob = new Blob([json], {type: 'application/json'});
            const link = document.createElement('a');
            link.download = `coprime_lattice_stats_${currentStats.N}x${currentStats.N}_${Date.now()}.json`;
            link.href = URL.createObjectURL(blob);
            link.click();
        };
        
        // Initial generation
        window.onload = () => {
            setTimeout(generateVisualization, 500);
        };
    </script>
</body>
</html>
